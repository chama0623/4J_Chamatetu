\documentclass[a4j]{jarticle}
    \usepackage[dvipdfmx]{graphicx}
    \usepackage[ top=25truemm,bottom=25truemm,left=25truemm,right=25truemm]
    {geometry}
    \usepackage{ascmac}
    \usepackage{array}
    \usepackage{here}
    \usepackage{url}
    \usepackage{listings, jlisting}
    \renewcommand{\lstlistingname}{リスト}
\lstset{language=c,
  basicstyle=\ttfamily\scriptsize,
  commentstyle=\textit,
  classoffset=1,
  keywordstyle=\bfseries,
  frame=tRBl,
  framesep=5pt,
  showstringspaces=false,
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny,
  tabsize=4
}

\makeatletter
\def\@thesis{プログラミング演習 レポート}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
\begin{center}
{\huge \@thesis \par} %修士論文と記載される部分
\vspace{10mm}
{\LARGE\bf \@title \par}% 論文のタイトル部分
\vspace{10mm}
{\Large \@date\par}	% 提出年月日部分
\vspace{20mm}
{\Large \@department \par}	% 所属部分
{\Large 学籍番号　\@id \par}	% 学籍番号部分
\vspace{10mm}
{\Large 氏名　\@author}% 氏名 
\end{center}
\par\vskip 1.5em
}

\title{ミニゲーム}
\date{提出期限　2021年1月18日 17:00}
\department{組番号　408}
\id{17406}
\author{金澤雄大}

    \begin{document}
    \maketitle
    \thispagestyle{empty}
    \clearpage
    \addtocounter{page}{-1}
    \section{目的}
    後期のプログラミング演習で学習した内容の理解度を高めるために,ミニゲームを作成することを目的とする.
    \section{ミニゲームの説明}
    本章では,次に示す6つの内容について述べる.
    \begin{enumerate}
        \item ゲームの概要
        \item プレイヤーと物件の設定
        \item ゲームの進行方法
        \item マップの設定
        \item 駅の設定
        \item 決算の処理
    \end{enumerate}    
    \subsection{ゲームの概要}
    ミニゲームとして,「桃太郎電鉄」\cite{mmtt}(以下,桃鉄)をイメージした「ちゃま鉄」を作成した.「ちゃま鉄」は鉄道会社の運営をイメージしたすごろく形式のゲームである.
    本ゲームの勝利条件は3年経過時に,自分の所持金と総資産の和を,他のプレイヤーよりも多くすることである.
    本ゲームは, 3年決戦で3人でのプレイを想定しており,CPUキャラは存在しない.また桃鉄における「貧乏神」,「すりの銀次」,「臨時収入」を代表とする要素は開発時間の都合上実装していない.

    \subsection{プレイヤーと物件の設定}
    プレイヤーおよび物件の設定について説明する.先述した通り,プレイヤー(社長と呼ぶ)は3人おり,ゲーム内ではターン順に「プレイヤー1社長」,「プレイヤー2社長」,「プレイヤー3社長」と
    呼ばれる仕様になっている.社長はゲーム内では,図\ref{iconshachou}の画像で表示される.各社長には色の設定が行われている.社長名と色の対応を次に示す.マップ上で表示される
    社長の画像やダイアログはこの色の設定で表示される仕様になっている.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=3.0]{player1.png}
        \caption{社長のアイコン}
         \label{iconshachou}
        \end{figure}
    
    \begin{itemize}
        \item プレイヤー1社長 $\cdots$ 青
        \item プレイヤー2社長 $\cdots$ ピンク
        \item プレイヤー3社長 $\cdots$ 黄色
      \end{itemize}
      　各社長には「所持金」,「総資産」という2つのパラメータが割り振られている.ゲームスタート時の所持金は1億円,総資産は0円である.所持金は社長が手元に持っているお金のことである.停車する駅には
      「物件」を購入できる「物件駅」というものがあり,物件を購入することで総資産を増やすことができる.図\ref{bukkenex}に長野駅の物件の例を示す.
      図\ref{bukkenex}には6つの物件がある.物件には「価格」,「収益率」という2つのパラメータがある.例えば「りんごえん」の場合,価格が「600万円」,収益率が「120\%」である.
      価格はその物件を購入するために必要な所持金であり,収益率は決算(後述)で手に入るお金の割合を示している.また,同じ駅の物件を1人の社長がすべて購入すると「独占」という
      状態になる.独占状態になった駅の収益率は2倍になるため,決算で2倍の収益が得られる仕様になっている.

      \begin{figure}[H]
        \centering
        \includegraphics[scale=1.5]{bukkenex.eps}
        \caption{物件の例(長野駅)}
         \label{bukkenex}
        \end{figure}
    
    \subsection{ゲームの進行方法}
    ゲームの進行について説明する.ここではゲームの進行の概要について説明し,実際の画面表示については実装と共に述べる.
    図\ref{processgame}にゲーム進行のフローチャートを示す.ゲームを開始すると,初期設定が行われ,タイトル画面が表示される.
    初期設定としてはゲームスタート時の駅の設定および年月の設定が行われる.ゲームスタート時の駅は長野駅,年月は「1年目4月」に設定される仕様にした.
    次に目的地の設定が行われる.目的地の設定が完了するとゲームのメイン部分である社長の行動が始まる.各社長はターン中に
    サイコロを1つふって出た目の数だけ進む,もしくはカードを使う,のどちらかの行動を行うことができる.なお,社長が目的地に到着すると
    目的地の再設定の処理が行われる.各社長が1回行動すると,年月の経過処理として1ヵ月経過する処理が行われる.
    年月の経過処理後の処理は月によって変化する.3月でない場合は再び社長の行動の処理が行われる.3月の場合は社長の行動の前に「決算」という処理が行われる.
    さらに3年目の場合は決算として最終成績が表示されゲームの終了処理が行われる.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=2.3]{processgame.eps}
        \caption{ゲームの進行}
         \label{processgame}
        \end{figure}

    \subsection{マップの設定}
    マップの設定について説明する.図\ref{map}に本ゲームのマップを示す.図\ref{map}の地名からも読み取れるように,本ゲームは長野県を舞台にしている.
    ただし,実際のゲームでは駅名は表示されない仕様になっている.マップは32$\times$32の画像を敷き詰める形で描画しており,サイズは960$\times$960である.
    なお,ウィンドウサイズは幅480,高さ320のに固定しているため,ゲーム中では行動中の社長を中心として画面におさまる部分だけを描画している.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.9]{map.eps}
        \caption{ゲームのマップ}
         \label{map}
        \end{figure}

    マップを描画する画像には表\ref{mapimage}に示す種類のものがある.
    これらの画像は「/mapparts」に保存されている.背景は季節によって変化する.月と季節の対応は次に示すようになっている.図\ref{map}の
    マップは背景が春の場合である.季節ごとに背景が変化する仕様は桃鉄を参考にした.
    \begin{itemize}
        \item 春 : 3月～5月 
        \item 夏 : 6月～8月 
        \item 秋 : 9月～11月 
        \item 冬 : 12月～2月 
      \end{itemize}

\begin{table}[H]
  \caption{マップとして描画される画像の種類}
\label{mapimage}
\begin{center}
    \begin{tabular}{c|c|c}\hline
        画像の意味 & 画像のファイル名 & 実際の色や模様 \\ \hline \hline
        背景(春) & season1.png & 明るい緑 \\ 
        背景(夏) & season2.png & 濃い緑 \\
        背景(秋) & season3.png & 茶色 \\
        背景(冬) & season4.png & 白 \\
        プラス駅 & map1.png & 青 \\
        マイナス駅 & map2.png & 赤 \\
        カード駅 & map3.png & 黄色 \\
        物件駅 & map4.png & 灰色 \\ 
        線路(縦) & map5.png & 灰色背景に黒の線路 \\ 
        線路(横) & map6.png & 灰色背景に黒の線路 \\ 
        目的地駅 & map7.png & 灰色背景に駅のマーク\\ \hline
    \end{tabular}
\end{center}
\end{table}

    \subsection{駅の設定}
    駅の設定について説明する.サイコロをふって移動した社長が停車できる駅の種類には,表\ref{mapimage}に示したように,「プラス駅」,「マイナス駅」,「カード駅」,「物件駅」,「目的地駅」の5つがある.
    プラス駅は停車するとお金がもらえる駅である.もらえるお金は夏が最も多く,冬が最も少ない仕様になっている.マイナス駅は停車すると所持金が減少する駅である.
    減少する金額は夏が最も少なく,冬が最も多い仕様になっている.減少する額によっては所持金が負になる,いわゆる借金という状態になることがある.この場合,
    物件を売却することで借金を返済する処理が行われる.本ゲームでの借金の返済は,売却する物件を選択する方式ではなく,自動で売却する物件を選ぶ方式を採用した.
    売却する物件の優先順位は次に示す通りである.優先順位が同じ物件が複数ある場合は,より借金額に近い物件から売却される.
    なお,所持している全ての物件を売却しても借金が返済できない場合は所持金が負になった状態でターンが終了する.
    \begin{enumerate}
        \item 独占している駅の物件でなく,借金額よりも価格が高い物件
        \item 独占している駅の物件でなく,借金額よりも価格が低い物件
        \item 独占している物件で,借金額よりも価格が高い物件
        \item 独占している物件で,借金額よりも価格が低い物件
    \end{enumerate}
    　カード駅は停車するとカードがもらえる駅である.カードは5枚まで所持することができ,カード駅に停車したときに既に5枚カードを持っている場合,この処理はスキップされる.
    カードは表\ref{cardlist}に示す8種類がある.カード名は桃鉄を参考にした.表\ref{cardlist}のカードのうち,急行カード,特急カード,新幹線カードの3種類は
    カードを仕様したあとにサイコロをふって移動することができる.他のカードについては,成功,失敗にかかわらずターンが終了する.
    \begin{table}[H]
        \caption{カード名と効果}
      \label{cardlist}
      \begin{center}
          \begin{tabular}{c|c}\hline
              カード名 & カードの効果 \\ \hline \hline
              急行カード & サイコロが2個に増える.\\
              特急カード & サイコロが3個に増える.\\
              新幹線カード & サイコロが4個に増える.\\
              サミットカード & すべての社長を自分のマスに集める.確率$\frac{2}{3}$で成功する.\\
              ぶっとびカード & ランダムな物件駅に移動する. \\
              10億円カード & 10億円が手に入る.\\
              徳政令カード & 借金を負っている社長の所持金が0円になる.\\
              剛速球カード & 他の社長のカードをすべて破棄する.確率$\frac{1}{2}$で成功する.\\ \hline
          \end{tabular}
      \end{center}
      \end{table}

      \subsection{決算の処理}
      決算の処理について説明する.決算は所持している物件に応じて各社長の所持金が増加する処理のことで, 3月が終了すると行われる
      .ある社長が決算で得られる金額$S$を計算する方法について説明する.物件を$n$個持っており,所持している$i$番目の物件の価格$p_i$,
      収益率$r_i$,その物件が所属する駅が自分の独占のとき$d_i=2$,独占でないとき$d_i=1$とする.このとき,決算で得られる金額$S$は式(\ref{kessan})で表せる.
      \begin{equation}
        S = \sum_{i=1}^{n} \frac{p_i r_i d_i}{100}
        \label{kessan}
      \end{equation}
      例えば,ある社長が,図\ref{bukkenex}の「やわたやいそごろう」と「アイススケートじょう」を所持している場合に
      決算でもらえる金額を計算してみる.式(\ref{kessan})に値を代入して計算を行うと,式(\ref{kessan_ex1})に示すように1800万円になる.
      この例では独占はしていないから$d_i$は常に1である.

      \begin{eqnarray}
        S &=& \sum_{i=1}^{n} \frac{p_i r_i d_i}{100} \\
          &=& \frac{1}{100} \left( 6000\times10^4 \cdot 20 + 20000\times10^4 \cdot 3 \right) \\
          &=& 1800 \times10^4
        \label{kessan_ex1}
      \end{eqnarray}    
      　本ゲームは3年決戦であるため,3年目の決算は「最終成績」という形で表示される.最終成績を表示した後はゲームを終了するように促す画面を表示する.
    
      \section{実行環境とビルド方法}
      本章では,実行環境,ビルド方法,ディレクトリ構造の3つについて述べる.
      \subsection{実行環境}
      実行環境を表\ref{env}に示す.gccとは「GNU Compiler Collection」の略称で,GNUプロジェクトが公開しているコンパイラのことである.
      makeはMakefileにプログラムのコンパイルやリンクの方法を指示することで,コンパイルを簡単に行うことができるツールのことである.
      makeを用いることは,gccコンパイル時に,長いオプションを入力しなくてよい,ファイルの更新を取得して必要なものだけをコンパイルしてくれる
      という利点がある.
      
      \begin{table}[H]
        \caption{実行環境}
      \label{env}
      \begin{center}
          \begin{tabular}{c|l}\hline
            CPU & Intel(R) Core(TM) i7-6500U 2.50GHz  \\ 
            メモリ & 16.0GB DDR4 \\
            OS & Microsoft Windows 10 Home \\
            gcc &  version 9.3.0 \\
            make & version 4.3 \\ \hline
          \end{tabular}
      \end{center}
      \end{table}
      
      \subsection{ビルド方法}
      ビルド方法について説明する.まず,「j17406.tar.gz」を保存したディレクトリに移動する.次にリスト\ref{kaito}に示すコマンドを実行する.
      リスト\ref{kaito}のコマンドを実行することで, j17406.tar.gzが解凍される.
      \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=kaito,caption=j17406.tar.gzの解凍]
gzip -dv j17406.tar.gz
tar xvf j17406.tar
        \end{lstlisting}

        解凍を行えたから,リスト\ref{make}の1行目のコマンドを実行してビルドを行う.リスト\ref{make}のコマンドを実行して
        「j17406.exe」が生成されていればビルド成功である.「j17406.exe」の実行はリスト\ref{make}の2行目のコマンドで行う.
        リスト\ref{make}の2行目のコマンドを実行して図\ref{sp4}に示す画面が表示されれば,ゲームの起動が成功している.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=make,caption=makeコマンド]
make
.\j17406.exe
        \end{lstlisting}  

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.8]{sp4.png}
        \caption{ゲームのスタート画面}
         \label{sp4}
        \end{figure}

      \subsection{ディレクトリ構造}
      リスト\ref{tree}に「/j17406」のディレクトリ構造を示す.リスト\ref{tree}はtreeコマンドを用いてディレクトリ構造を
      表示したものである.リスト\ref{tree}では「-L」オプションを用いて深さ1のファイル,ディレクトリのみを表示している.深さ1のファイルのみを表示しているのは
      ,日本語画像や物件情報を保存しているディレクトリがあるため全てのファイルを表示すると構造が見にくくなってしまうからである.
      ゲームの実装のためのコードは「game.c」および「j17406.c」に記述している.定数および関数の定義は
      「game.h」に記述している.画像は,画像の種類ごとにディレクトリを分けて保存している.ディレクトリ名と保存している画像の種類は
      表\ref{imgdir}の通りである.property.txtおよび「/property」に保存されているtxtファイルは駅の情報および物件の情報を保存している.
    
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=tree,caption=ディレクトリ構造]
j17406
├── Makefile
├── charimg
├── description.html
├── descriptionimg
├── dice
├── eventparts
├── game.c
├── game.h
├── icon.o
├── j17406.c
├── mapparts
├── property
├── property.txt
└── readme.txt
        \end{lstlisting}    
        
      \begin{table}[H]
        \caption{画像を保存するディレクトリ}
      \label{imgdir}
      \begin{center}
          \begin{tabular}{c|c}\hline
            ディレクトリ名 & 保存している画像の種類 \\ \hline \hline
            /charimg & 日本語を画面に表示するための画像 \\
            /dice & サイコロの画像 \\ 
            /eventparts & 社長のアイコン,スタート画面,決算,ゲーム終了画面 \\ 
            /mapparts & マップ描画のための画像 \\
            /descriptionimg & description.html(説明書)の画像 \\ \hline
          \end{tabular}
      \end{center}
      \end{table}
        
    
    \section{プログラムの説明と実行結果}
    本章では次に示すプログラムの説明および実行結果について述べる.なお,プログラム中に登場する定数の値は付録の
    「game.h」(リスト\ref{code1})を参照してほしい.
    \begin{enumerate}
        \item playerstatus構造体
        \item propertystatus構造体
        \item stationstatus構造体
        \item Map配列の定義
        \item 日本語プロトコルの定義
        \item 画像の読み込み
        \item 画像および日本語の表示
        \item 駅および物件情報の読み込み
        \item メイン関数(j17406.c)
        \item ウィンドウサイズ変更への対応(Reshape関数)
        \item ゲームの進行状況管理
        \item ゲームの初期化とタイトル画面の表示
        \item 目的地の設定処理
        \item プレイヤーおよびマップの描画処理
        \item ターンのはじめの処理
        \item サイコロをふる処理
        \item マス移動および停車駅の判定処理
        \item 物件駅の処理
        \item プラス駅の処理
        \item マイナス駅および借金の処理
        \item カード駅の処理
        \item ターン終了時の処理
        \item 決算および最終成績の処理
    \end{enumerate}    

    \subsection{playerstatus構造体}
    playerstatus構造体の定義と初期化について説明する.まず,playerstatus構造体の定義について説明する.
    playerstatus構造体は一人の社長の情報を保持するための構造体である.リスト\ref{playerstatus}にplayerstatus構造体の
    定義を示す. playerstatus構造体は「社長名」,「所持金」,「総資産」,「現在の座標(x,y)」,「カード枚数」,「カードの通し番号」の7つをメンバとして持っている.
    所持金および総資産は万円単位で扱うものとする.例えば所持金が「2200万円」場合,メンバmoneyには2200が代入される.これ以降にも金額を
    扱うための変数が登場するが,そのすべての変数は金額を万円単位で扱うものとする.
    また,11行目のようにplayerstatus構造体の配列を定義することで,プレイ人数3人分の情報を保持する構造体の配列を作成している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=playerstatus,caption=playerstatus構造体の定義と初期化]
// プレイヤーの情報構造体
struct playerstatus{
    char name[NAMEMAX]; // プレイヤー名
    int money; // 所持金
    int assets; // 総資産
    int x; // x座標(実描画座標)
    int y; // y座標(実描画座標)
    int cardnum; // 持っているカード枚数
    int card[CARDMAX]; // カードの番号記憶
};
    
    typedef struct playerstatus player;
    player players[PLAYERNUM]; // 人数分の配列を確保
    \end{lstlisting}

    次にplayerstatus構造体を初期化する関数について説明する.リスト\ref{InitPlayer}に,playerstatus構造体を初期化する関数である
    InitPlayer関数のコードを示す. InitPlayer関数の内部では,for文を用いてplayerstatus構造体の配列を初期化している.
    リスト\ref{InitPlayer}中の定数の値はINITXが416(13$\times$32),INITYが224(7$\times$32),INITMONEYは10000である.
    座標(13,7)はマップを描画するための配列における長野駅の座標である. playerstatus構造体の座標(x,y)は画面に描画する実座標を
    保持する仕様にしているため画像サイズを示す定数IMGSIZE倍している.定数IMGSIZEの値は32である.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=InitPlayer,caption=InitPlayer関数]
// プレイヤー構造体を初期化
void InitPlayer(void){
    int i,j;
    for(i=0;i<PLAYERNUM;i++){
        //プレイヤーhoge
        sprintf(players[i].name,"llpureiiyallms%d",i+1);
        players[i].x=INITX;
        players[i].y=INITY;
        players[i].money=INITMONEY;
        players[i].assets=0;
        players[i].cardnum=0;
        for(j=0;j<CARDMAX;j++){
            players[i].card[j]=0;
        }
    }
}
            \end{lstlisting}

    \subsection{propertystatus構造体}
    propertystatus構造体は一つの物件の情報を保持するための構造体である. propertystatus構造体の定義をリスト\ref{propertystatus}に示す.
    propertystatus構造体は「物件名」,「物件保持者」,「価格」,「収益率」の4つをメンバとして持っている.物件保持者は表\ref{whohold}のルールで扱うものとする.
   \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=propertystatus,caption=propertystatus構造体の定義]
   // 物件情報構造体
   struct propertystatus{
   char name[STRMAX]; // 物件名
   int holder; // 物件所持者
   int price; // 価格
   int earnings; // 収益率
   };
   
   typedef struct propertystatus property;
   \end{lstlisting}
   
   \begin{table}[H]
     \caption{物件保持者メンバの意味}
   \label{whohold}
   \begin{center}
       \begin{tabular}{c|c}\hline
       値 & 保持者 \\ \hline \hline
         0 & 保持者なし \\
         1 & 社長1 \\
         2 & 社長2 \\
         3 & 社長3 \\ \hline
       \end{tabular}
   \end{center}
   \end{table}

    \subsection{stationstatus構造体}
stationstatus構造体は一つの駅の情報を保持するための構造体である.リスト\ref{stationstatus}にstationstatus構造体の定義を示す.
stationstatus構造体は,「駅名」,「駅の座標(x,y)」,「独占フラグ」,「物件の数」,「propertystatus構造体の配列」の6つをメンバとして持つ.
駅の座標(x,y)はplayerstatus構造体のような実座標ではなく,マップを描画するための配列のインデックスである.独占フラグは
その駅を誰が独占しているかを判別するために用いる.独占フラグの値とその意味は表\ref{whohold}と同じである.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=stationstatus,caption=stationstatus構造体の定義と初期化]
// 駅情報構造体
struct stationstatus{
char name[STRMAX]; // 駅名
int x; // x座標
int y; // y座標
int ismonopoly; // 独占フラグ
int propertynum; // 物件数
property plist[PROPERTMAX]; // 物件情報構造体の配列
};

typedef struct stationstatus station;
station stations[STATIONNUM]; // 駅の数分の配列を確保
station distination; // 目的地配列
\end{lstlisting}

    \subsection{Map配列の定義}
    マップの情報はMap配列が保持している.Map配列の定義をリスト\ref{Maparray}に示す.
    マップのサイズは30$\times$30で,配列のサイズは30$\times$31である.
    x方向の配列のサイズが1大きいのは,null文字を格納するためである. Map配列の文字列は
    「A」,「B」,「C」,「P」,「M」,「-」,「\textbar」のいずれかの文字から構成されている.表\ref{mapstr}に
    文字と実際に表示される画像の関係を示す.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=Maparray,caption=Map配列の定義]
// マップ配列
char Map[YMAX][XMAX+1] = { //NULL文字に気を付ける
       //012345678901234567890123456789      
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", // 0
        "AAAAAAAAAAAP-M--M-BAAAAAAAAAAA", // 1
        "AAAAAAAAAAA|A|AAAAAAAAAAAAAAAA", // 2
        "AAAAAAAAAC-M-BAAAAAAAAAAAAAAAA", // 3
        "AAAAAAAAA|AAA|AAAAAAAAAAAAAAAA", // 4
        "AAAAAAAAAP-M-P--CAAAAAAAAAAAAA", // 5
        "AAAAAAAAA|AAA|AA|AAAAAAAAAAAAA", // 6
        "AAAB-C---C---B--P--BAAAAAAAAAA", // 7
        "AAA|AAAAA|AAAAAA|AA|AAAAAAAAAA", // 8
        "AAAMAAAAABAAAAAAM--P-CAAAAAAAA", // 9
        "AAA|AAAAA|AABAAAAAA|A|AAAAAAAA", // 0
        "AAAM-MAAA|AA|AAAAAAB-CAAAAAAAA", // 1
        "AAA|A|AAAB--M--PAAA|AAAAAAAAAA", // 2
        "AAAM-MAAA|AAAAAAAAAMAAAAAAAAAA", // 3
        "AAA|AAAAA|AAAAAAAAA|AAAAAAAAAA", // 4
        "AAA|AAAAAB-P-M-M-P-B-P-BAAAAAA", // 5
        "AAAMAAAAA|AAA|AAAAAAAAA|AAAAAA", // 6
        "AAA|AAAAAPAAAPAAAAAAAAA|AAAAAA", // 7
        "AAAB-MAAA|AAA|AAAAAAAAABAAAAAA", // 8
        "AAA|AAAAAP---CAAAAAAAAA|AAAAAA", // 9
        "AAABAAAAA|AAAAAAAAAAAAA|AAAAAA", // 0
        "AAA|AAAAA|AAAAAAAAAAAAA|AAAAAA", // 1
        "AAAM-M---B--C--P-MAAAAA|AAAAAA", // 2
        "AAAAAAAAA|AAAAAAA|AAP--PAAAAAA", // 3
        "AAAAAAAAA|AAAAAAA|AA|AA|AAAAAA", // 4
        "AAABAC-M-C-----M-B--C--P--PAAA", // 5
        "AAA|A|A|A|AAAAA|A|AAAAA|AAAAAA", // 6
        "AAAM-P-P-B-CAAA|A|AAAAABAAAAAA", // 7
        "AAAAAAAAAAAAAAAM-P--BAAAAAAAAA", // 8
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"  // 9
};
    \end{lstlisting}

    \begin{table}[H]
        \caption{文字と画像の対応}
      \label{mapstr}
      \begin{center}
          \begin{tabular}{c|c}\hline
            文字 & 表示される画像 \\ \hline \hline
            A & 背景 \\ 
            B & 物件駅 \\ 
            C & カード駅 \\ 
            P & プラス駅 \\ 
            M & マイナス駅 \\ 
            - & 線路(横) \\ 
            \textbar  & 線路(縦) \\ \hline
          \end{tabular}
      \end{center}
      \end{table}

    \subsection{日本語プロトコルの定義}
    桃鉄をイメージしたゲームを実装するうえで,日本語を画面に表示できなければ,ローマ字が並んでわかりにくい.しかしGLUTは日本語に対応していない.そこで画像を用いて日本語をゲーム
    画面に描画する機能を作成した.これを日本語プロトコルと呼ぶことにする.文字色は黒と赤のどちらかで描画することが可能である.
作成した日本語プロトコルでは次に示す文字を画面に表示することができる.一部のアルファベット,記号,漢字をまとめて特殊文字と呼ぶことにする.
\begin{itemize}
  \item 50音(ひらがな,カタカナ)
  \item 濁音(ひらがな,カタカナ)
  \item 半濁音(ひらがな,カタカナ)
  \item 小文字(っ,ゃ,ゅ,ょ)(ひらがな,カタカナ)
  \item 数字
  \item 一部のアルファベット(W,A,S,D,E,Q)
  \item 一部の記号(読点,句点,\%,マイナスの記号(-),プラスの記号(+))
  \item ゲームに頻出する漢字(億,万,円)
\end{itemize}

これらの画像は「/charimg」に保存されている.画像のサイズはすべて32$\times$32pxである.画像名の意味は図\ref{howname}の通りである.
どの文字か判別する2文字はコード中で日本語を表示するための文字列に対応している.実際の文字と日本語プロトコルにおける文字の表現
方法は表\ref{jpp}の通りである.改行およびスペースは画像にはないが,画像を表示する位置を調整することで表現できる. ひらがな,かたかなの
切り替えは「ll」という文字列で表現している.表\ref{jpp}の情報はリスト\ref{jpProtcolarray}に示すように定義されている.\\
　日本語プロトコルの使用例を紹介する.例えば画面に「あかさたな」と表示したい場合,文字列「aakasatana」を文字列を表示するための関数に渡すことで
日本語の表示を実現している.「チャマテツ」のようにカタカナを表示したい場合は「lltilamatetull」というように「ll」でカタカナにしたい文字を囲むことで
カタカナを画面に表示することができる.このように,日本語プロトコルの表示は非常にわかりにくいが,コード中で日本語プロトコルの文字列が頻繁に登場する.
コード中では日本語プロトコル使用部分の上の行に,実際に表示される文字をコメントアウトとして記述しているから参考にしてほしい.

\begin{figure}[H]
  \centering
  \includegraphics[scale=1.7]{howname.eps}
  \caption{画像の名前の意味}
   \label{howname}
  \end{figure}    

  \begin{table}[H]
    \caption{日本語プロトコルの文字表現}
  \label{jpp}
  \begin{center}
      \begin{tabular}{c|c|c|c|c}\hline
あ aa & い ii & う uu & え ee & お oo \\ 
か ka & き ki & く ku & け ke & こ ko \\ 
さ sa & し si & す su & せ se & そ so \\ 
た ta & ち ti & つ tu & て te & と to \\ 
な na & に ni & ぬ nu & ね ne & の no \\ 
は ha & ひ hi & ふ hu & へ he & ほ ho \\ 
ま ma & み mi & む mu & め me & も mo \\ 
や ya & -  & ゆ yu & -  & よ yo \\ 
ら ra & り ri & る ru & れ re & ろ ro \\ 
わ wa & -  & を wo & -  & ん nn \\ 
ゃ la & - & ゅ lu & っ lt & ょ lo \\ 
が ga & ぎ gi & ぐ gu & げ ge & ご go \\ 
ざ za & じ zi & ず zu & ぜ ze & ぞ zo \\
だ da & ぢ di & づ du & で de & ど do \\
ば ba & び bi & ぶ bu & べ be & ぼ bo \\ 
ぱ pa & ぴ pi & ぷpu &  ぺ pe & ぽ po \\ 
0 　0 & 1 　1 & 2 　2 & 3 　3 & 4 　4 \\ 
5 　5 & 6 　6 & 7 　7 & 8 　8 & 9 　9 \\ 
円 ex & 万 mx & 億 ox & \% px & - ms \\ 
+ ps & 句点 mr & 読点 tn & Q xq & W xw \\ 
E xe & A xa & S xs & D xd & - \\ 
改行 xx & スペース ss & ll 文字切り替え & - & - \\ \hline
      \end{tabular}
  \end{center}
  \end{table}
  
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=jpProtcolarray,caption=jpProtcol配列]
// 日本語プロトコル
char jpProtcol[JPMAX+SPMAX][3] = {"aa","ii","uu","ee","oo",
                        "ka","ki","ku","ke","ko",
                        "sa","si","su","se","so",
                        "ta","ti","tu","te","to",
                        "na","ni","nu","ne","no",
                        "ha","hi","hu","he","ho",
                        "ma","mi","mu","me","mo",
                        "ya","yu","yo",
                        "ra","ri","ru","re","ro",
                        "wa","wo","nn",
                        "lt","la","lu","lo",
                        "ga","gi","gu","ge","go",
                        "za","zi","zu","ze","zo",
                        "da","di","du","de","do",
                        "ba","bi","bu","be","bo",
                        "pa","pi","pu","pe","po",
                        "0","1","2","3","4","5"
                        ,"6","7","8","9",
                        "ex","mx","ox","px","ms","ps",
                        "mr","tn","xq","xw","xe","xa","xs","xd"
                        };

  \end{lstlisting} 
  
  \subsection{画像の読み込み}
  画像を読み込む方法について説明する.リスト\ref{readImg}に画像を読み込むためのreadImg関数のコードを示す.
  処理の内容はファイル名や読み込み先を変えて画像を読み込んでいるだけだから,リスト\ref{readImg}の7行目から11行目のイベントマップの読み込みを
  例に説明する.画像を読み込むためには2つの変数が必要である.今の例ではspimgとspinfoである.変数spimgには読み込んだ画像を識別するための値が
  代入され,変数spinfoには読み込んだ画像の横幅,縦幅を代表とする情報が格納される.これらの変数にpngBind関数を用いて読み込んだ画像の
  情報を与えることで画像の読み込みを行っている.
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=readImg,caption=readImg関数]
// 画像読み込み
void readImg(void){
    int i;
    char fname[100];

    // イベントマップ読み込み
    for(i=0;i<SP_NUM;i++){
        sprintf(fname,".\\eventparts\\sp%d.png",i+1);
        spimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &spinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);        
    }

   // 季節マップ読み込み 
    for(i=0;i<SEASON_NUM;i++){
        sprintf(fname,".\\mapparts\\season%d.png",i+1);
        seasonimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &seasoninfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);        
    }

    // マップイメージ読み込み
    for(i=0;i<=MAP_NUM;i++){
        sprintf(fname,".\\mapparts\\map%d.png",i+1);
        mapimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &mapinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // プレイヤー画像を読み込み
    for(i=0;i<PLAYERNUM;i++){
        sprintf(fname,".\\eventparts\\player%d.png",i+1);
        playerimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &playerinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }

    // サイコロの画像を読み込み
    for(i=0;i<DICEMAX;i++){
        sprintf(fname,".\\dice\\dice%d.png",i+1);
        diceimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &diceinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Hiragana black
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\h%sblack.png",jpProtcol[i]);
        hblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }

    // read Hiragana red
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\h%sred.png",jpProtcol[i]);
        hredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Katakana black
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\k%sblack.png",jpProtcol[i]);
        kblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &kblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Katakana red
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\k%sred.png",jpProtcol[i]);
        kredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &kredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Special Str red
    for(i=JPMAX;i<JPMAX+SPMAX;i++){
        sprintf(fname,".\\charimg\\%sred.png",jpProtcol[i]);
        hredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Special Str black
    for(i=JPMAX;i<JPMAX+SPMAX;i++){
        sprintf(fname,".\\charimg\\%sblack.png",jpProtcol[i]);
        hblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
}
      \end{lstlisting}

  \subsection{画像および日本語の表示}  
  画像および日本語をゲーム画面に表示する方法について説明する.まず,画像を表示する方法について説明する.画像の表示
  はリスト\ref{PutSprite}に示すPutSprite関数で行っている. PutSprite関数は「Springs of C」\cite{springc}から引用した関数である.
  リスト\ref{PutSprite}のコードでは,引用した関数に,引数として画像の表示倍率scaleを加え,画像の縮小を行えるようにした.
  画像の表示倍率はリスト\ref{PutSprite}の6行目および7行目でテクスチャの幅と高さをscale倍することで行っている.
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=PutSprite,caption=PutSprite関数]
// (x,y)に大きさscaleの画像を表示
void PutSprite(int num, int x, int y, pngInfo *info,double scale)
{
    int w, h;  //  テクスチャの幅と高さ

    w = info->Width*scale;   //  テクスチャの幅と高さを取得する
    h = info->Height*scale;

    glPushMatrix();
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, num);
    glColor4ub(255, 255, 255, 255);

    glBegin(GL_QUADS);  //  幅w, 高さhの四角形

    glTexCoord2i(0, 0); 
    glVertex2i(x, y);

    glTexCoord2i(0, 1);
    glVertex2i(x, y + h);

    glTexCoord2i(1, 1);
    glVertex2i(x + w, y + h);

    glTexCoord2i(1, 0);
    glVertex2i(x + w, y);

    glEnd();

    glDisable(GL_TEXTURE_2D);
    glPopMatrix();
}
          \end{lstlisting} 

    次に日本語の表示方法について説明する.リスト\ref{jpfunc}に日本語を表示するための関数であるdrawChar関数および
    drawString関数のコードを示す. drawChar関数は「1文字」の日本語を表示する関数であり, drawString関数はdrawChar関数を
    連続して呼び出して文字列を表示する関数である. drawChar関数は引数としてjpProtcol配列(リスト\ref{jpProtcolarray})の
    インデックスnum,ひらがな/カタカナのどちらで表示するかを示すkh,黒/赤のどちらで描画するかを示すcolor,描画する実座標(x,y),
    表示倍率scaleの6つを受け取る.引数khは0のときひらがな,1のときカタカナである.引数colorは0のとき黒,1のとき赤である.
    drawChar関数の内部では,受け取った引数から表示する文字の種類を判断し, PutSprite関数で描画する処理を行っている.\\
    　drawString関数は引数として描画する文字列string,文字色color,実座標(x,y),表示倍率scaleの5つを受け取る. drawString関数
    の内部では,まず引数として受け取った文字列stringを1文字または2文字ずつ取り出して,文字の種類を判断している.リスト\ref{jpfunc}では,
    29行目および30行目が数字かどうかの判別を行っている部分である.日本語の判別は35行目,特殊文字は41行目で判定している.例外として
    ひらがな/カタカナ切り替えは47行目,改行は51行目で判定している.空白は判定していないが,これは該当する文字がない場合に何も
    描画せずに文字を表示する位置がずれることを利用している.このため,空白は「ss」以外の文字列でも表現できるがコードのわかり
    やすさという観点から「ss」という文字に統一している.文字の種類の判断が行えたら, jpProtcol配列におけるその文字のインデックス
    および描画のための情報をdrawChar関数に渡して描画を行っている.最後に58行目から63行目で次に表示する文字の位置を計算する処理
    を行っている.これらの処理によって画面に日本語を描画している.

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=jpfunc,caption=日本語表示のための関数]
// 1文字の日本語を表示
// int kh : 0,Hiragana 1,Katakana
// int color 0,black 1,red
void drawChar(int num,int kh,int color,int x,int y,double scale){
    if(kh==0){
        if(color==0){ // hiragana black
            PutSprite(hblackimg[num], x, y, &hblackinfo[num],scale);
        }else{ //hiragana red
            PutSprite(hredimg[num], x, y, &hredinfo[num],scale);
            }
        }else{ 
        if(color==0){ // katakana black
            PutSprite(kblackimg[num], x, y, &kblackinfo[num],scale);
        }else{ // katakana red
            PutSprite(kredimg[num], x, y, &kredinfo[num],scale);
        }
    }
}

// 引数stringの文字列を表示
void drawString(char *string,int color,int xo,int yo,double scale){
    int i,j;
    int len = strlen(string);
    int x=xo;
    int y=yo;
    int flg;
    int kh=0;
    for(i=0;i<len;i++){
        flg=string[i]-'0'; // インデクス計算
        if((flg>=0)&&(flg<=9)){ // 数字描画
            drawChar(JPMAX+flg,0,color,x,y,scale);
            flg=1;
        }else{
            for(j=0;j<JPMAX;j++){ //日本語描画
                if((jpProtcol[j][0]==string[i])&&(jpProtcol[j][1]==string[i+1])){
                    drawChar(j,kh,color,x,y,scale);
                    break;
                }
            }       
            for(j=JPMAX+10;j<JPMAX+SPMAX;j++){ //特殊文字描画
                if((jpProtcol[j][0]==string[i])&&(jpProtcol[j][1]==string[i+1])){
                    drawChar(j,kh,color,x,y,scale);
                    break;
                }
            }
            flg=1;
            if((string[i]=='l')&&(string[i+1]=='l')){ //ひらがな/カタカナ切り替え
                kh=1-kh;
                flg=0;
            }
            if((string[i]=='x')&&(string[i+1]=='x')){ // 改行
                x=xo;
                flg=0;
                y+=IMGSIZE*scale;
            }     
            i++;
        }
        if(flg==1){ // 次の座標に移動
            x+=IMGSIZE*scale;
            if(x>InitWidth-22){
                x=xo;
                y+=IMGSIZE*scale;
            }
        }
    }
}

                  \end{lstlisting} 

    日本語の中でも,金額だけを表示したい場合がある.このため,引数として金額を与えると画面に表示するを作成した.
    リスト\ref{drawMoney}に金額を画面に表示する関数であるdrawMoney関数のコードを示す. drawMoney関数は
    引数として受け取った金額moneyを座標(x,y)に表示する関数である.引数colorで色,scaleで大きさの指定を行うことも
    可能である. 金額の表示方法について説明する.まず,リスト\ref{drawMoney}の6行目および7行目で,引数として受け取った金額moneyを
    億,万の単位に分割する処理を行っている.金額あｇ負のときには符号を表示する必要があるから,符号によって処理を変える必要がある.
    8行目から17行目が金額が0より大きいとき,18行目から31行目が金額が負のときの処理である.金額が0より大きいとき,
    文字列fnameに日本語プロトコルにおける「hoge億huga万」と表示されるように文字列を代入している.金額が負のときは「ms」を
    文字列の先頭につけることでマイナスを表す符号「-」が表示されるように処理している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=drawMoney,caption=drawMoney関数]
// 数字を描画
void drawMoney(int money,int x,int y,int color,double scale){
    char fname[50];
    int oku,man;
    // 億の桁,万の桁を計算
    oku = money/10000;
    man = money%10000;
    if(money>=0){ // お金がプラスの時
        if(oku!=0){
            if(man!=0){
                sprintf(fname,"%dox%dmxex",oku,man);
            }else{
                sprintf(fname,"%doxex",oku);
            }
        }else{
            sprintf(fname,"%dmxex",man);
        }
    }else{ // お金がマイナスの時
    // 数字部分の符号を反転
        oku*=-1;
        man*=-1;
        if(oku!=0){
            if(man!=0){
                sprintf(fname,"ms%dox%dmxex",oku,man);
            }else{
                sprintf(fname,"ms%doxex",oku);
            }
        }else{
            sprintf(fname,"ms%dmxex",man);
        }        
    }
    // 画面出力
    drawString(fname,color,x,y,scale);
}  
    \end{lstlisting} 

  \subsection{駅および物件情報の読み込み}
  駅および物件の情報を読み込む方法について説明する.動作確認は次節のメイン関数で行う.まず,駅の情報を読み込む方法について説明する.
  駅の情報はproperty.txtに保存されている.リスト\ref{propertytxt}にproperty.txtの内容を示す. property.txt
  は「駅名 x座標,y座標」という形式ですべての駅の情報が保存されている.駅名は日本語プロトコルにおける
  駅名の表示である.座標は実座標ではなく, Map配列(リスト\ref{Maparray})のインデックスである.
  例えば飯山駅の場合,駅名が「iiiiyama」, Map配列における座標が(13,3)になっている.リスト\ref{Maparray}のMap配列の
  要素(13,3)を確認すると「B」つまり物件駅になっている.
  また,図\ref{map}からこの位置にある駅は飯山駅であることがわかる.これらよりproperty.txtで
  定義した駅名および座標が,Map配列や画面表示と合致していることが確認できた.同様にして全ての駅について
  駅名と座標が間違っていないことを筆者は確認した.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=propertytxt,caption=property.txt]
nozawaoonnsenn 18,1
iiiiyama 13,3
togakusi 9,9
nagano 13,7
oobuse 19,7
suzaka 19,11
matusiro 12,10
sinonoii 9,12
hakuba 3,7
oooomati 3,18
tikuma 9,15
uueeda 19,15
karuiizawa 23,15
aadumino 3,20
saku 23,18
matumoto 9,22
suwa 17,25
kiso 3,25
ookaya 9,27
iiiida 20,28
iina 23,27
        \end{lstlisting}   
    
    property.txtの形式が確認できたから,これを読み込む関数について説明する.リスト\ref{readStation}に駅の情報を読み込むための関数
    であるreadStation関数のコードを示す.リスト\ref{readStation}においてファイルから読み取った情報をstationstatus構造体に代入しているのは
    11行目から14行目である.11行目でfscanf関数を用いてファイルから「駅名 x座標,y座標」という情報を読み取り,構造体に代入している.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=readStation,caption=readStation関数]
// ファイルから駅情報を取得
// stations構造体を初期化
void readStation(void){
    FILE *fp;
    int i=0;
    fp=fopen("property.txt","r");
    if(fp==NULL){ // 開けなかったとき
        printf("file not found");
        exit(0);
    }else{ // 駅名と座標を取得
        while(fscanf(fp,"%s %d,%d",stations[i].name,&stations[i].x,&stations[i].y)!=EOF){
            stations[i].ismonopoly=0; // 独占フラグ初期化
            i++;
        }
        fclose(fp);
    }
}

        \end{lstlisting}     
    
    次に物件の情報を読み込む方法について説明する.物件の情報は「/property」に「駅名.txt」という形式で保存している.
    駅名は日本語プロトコルにおける駅名である.
    リスト\ref{naganotxt}およびリスト\ref{matumototxt}に物件情報を保存しているファイルの例を示す.リスト\ref{naganotxt}は
    長野駅,リスト\ref{matumototxt}は松本駅である.物件の情報は「物件名 価格,収益率」という形式で保存している.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=naganotxt,caption=/property/nagano.txt]
rinngoeenn 600,120
rinngoeenn 600,120
yawatayaiisogorouu 6000,20 
llaaiisusukellmslltollzilouu 20000,3 
zennkouuzi 110000,30
naganokouusenn 600000,1
\end{lstlisting}  

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=matumototxt,caption=/property/matumoto.txt]
giluuuniluuullpannll 1200,130 
kamikouuti 12000,80
sinnsiluuudaiigaku 60000,30
aasamaoonnsenn 80000,4
kiluuukaiitigaltkouu 90000,5
matumotozilouu 150000,5
\end{lstlisting}     

    物件情報の保存形式が確認できたから,これを読み込む関数について説明する.リスト\ref{readProperty}に
    物件情報を読み込む関数であるreadProperty関数のコードを示す.リスト\ref{readProperty}において
    ファイルから読み取った情報をpropertystatus構造体に代入しているのは,15行目および16行目である.
    readStation関数と同様にfscanf関数を用いてファイルから「物件名 価格,収益率」という情報を読み取り,構造体に代入している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=readProperty,caption=readProperty関数]
// ファイルから物件情報を取得
void readProperty(void){
    FILE *fp;
    int i,j;
    char fname[100];
    for(i=0;i<STATIONNUM;i++){
        sprintf(fname,".\\property\\%s.txt",stations[i].name);
        fp=fopen(fname,"r");
        j=0;
        if(fp==NULL){ // 開けなかったとき
            printf("file not found in %s",stations[i].name);
            exit(0);
        }else{
            // 物件名,値段,収益率を取得
            while(fscanf(fp,"%s %d,%d",stations[i].plist[j].name,
            &stations[i].plist[j].price,&stations[i].plist[j].earnings)!=EOF){
            stations[i].plist[j].holder=0; // 購入フラグ初期化
            j++;
        }
        stations[i].propertynum=j; // 物件数を保存
        fclose(fp);
    }

    }   
}
                \end{lstlisting}  

  \subsection{メイン関数(j17406.c)}
メイン関数のコードについて説明する.リスト\ref{main}にメイン関数のコードを示す.
メイン関数ではウィンドウの生成,画像の読み込み,構造体の初期化,コールバック関数の登録,メインループ呼び出しの5つの処理を行っている.
ウィンドウの生成は12行目および13行目で行っている.12行目で生成するウィンドウのサイズを指定し,13行目で
ウィンドウを生成する処理を行っている.画像の読み込みの関数であるreadImg関数は23行目で実行している.\\
　構造体の初期化は24行目から26行目で行っている.
構造体の初期化が正確に行われていることを確認するために,
デバッグ用の関数としてdispPlayer関数およびdispStation関数を作成した.リスト\ref{debugfunc}にdispPlayer関数およびdispStation関数の
定義を示す.これらの関数はリスト\ref{main}の27行目および28行目で実行している.実際に提出したファイルではコメントアウトしているため
実行はされていない. dispPlayer関数は社長の情報を保持するplayerstatus構造体内容をすべてコンソール出力する関数である.
dispPlayer関数には引数として表示する範囲を指定できる変数detailがある.引数として0を与えるとすべての社長の情報を表示し,
1,2,3のいずれかを与えると表\ref{whohold}に対応する社長の情報のみが表示される.ここでは引数として0を与え,すべての
社長の情報を表示する機能のみを用いる. dispStation関数は駅および物件の情報を保持するstationstatus構造体およびpropertystatus構造体の内容を
すべて表示する関数である. dispStation関数も引数として表示する範囲を指定できる変数detailがある.引数として
0を与えた場合は全ての駅の情報を表示し,1以上の整数を与えた場合は,対応するインデックスの情報のみが表示される仕様になっている.
インデックスと駅の対応は,リスト\ref{propertytxt}の1行目の野沢温泉駅を0,2行目の飯山駅を1というふうに行数-1の駅が対応している.\\
　リスト\ref{main}の32行目から35行目ではコールバック関数の登録を行っている.
コールバック関数とはキーボード入力や画面のリサイズを代表とするイベントが発生したときに実行される関数のことである. 
最後に37行目でglutMainLoop関数を実行することで,メインループを呼び出す処理を行っている.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=main,caption=main関数]
#include <GL/glut.h>
#include <GL/glpng.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "game.h"

int main(int argc, char **argv)
{
    srand((unsigned) time(NULL));
    glutInit(&argc, argv);
    glutInitWindowSize(InitWidth,InitHeight);
    glutCreateWindow("Chamatetu");
    glutInitDisplayMode(GLUT_RGBA | GLUT_ALPHA);
    glClearColor(1.0, 1.0, 1.0, 0.0);

    //  テクスチャのアルファチャネルを有効にする設定
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    
    // 画像読み込みと構造体の初期化
    readImg();
    InitPlayer();
    readStation();
    readProperty();
    dispPlayer(0); // デバッグ用
    dispStation(0); // デバッグ用
    turnstatus=0;
    inflg=0; // 進行状況を初期化
    //イベント登録
    glutReshapeFunc(Reshape);
    glutDisplayFunc(Display);
    glutKeyboardFunc(keyboard);
    glutTimerFunc(RESHAPETIME, Timer, 0);
    //  イベントループ突入
    glutMainLoop();

    return(0);
}
\end{lstlisting}  

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=debugfunc,caption=構造体の初期化を確認するための関数]
// デバッグ用関数 	
// プレイヤー構造体を表示	
// detail : 0 全部表示 , else その番号の駅を表示	
void dispPlayer(int detail){	
    int i,j;	
    if(detail==0){	
        for(i=0;i<PLAYERNUM;i++){	
            printf("--------------------\n");	
            printf("%s社長 (%d,%d)\n",players[i].name,
            players[i].x,players[i].y);	
            printf("\n");	
            printf("所持金 : %d\n",players[i].money);	
            printf("総資産 : %d\n",players[i].assets);
            printf("カード枚数 : %d\n",players[i].cardnum);
            for(j=0;j<CARDMAX;j++){
                printf("%d ",players[i].card[j]);
            }	
            printf("\n--------------------\n\n");	
        }	
    }else{	
        printf("--------------------\n");	
        printf("%s社長 (%d,%d)\n",players[detail-1].name,
        players[detail-1].x,players[detail-1].y);	
        printf("\n");	
        printf("所持金 : %d\n",players[detail-1].money);	
        printf("総資産 : %d\n",players[detail-1].assets);
        printf("カード枚数 : %d\n",players[detail-1].cardnum);
        for(j=0;j<CARDMAX;j++){
            printf("%d ",players[detail-1].card[j]);
        }		
        printf("\n--------------------\n\n");   	
    }	
}

// デバッグ用関数	
// 駅情報を表示	
void dispStation(int detail){	
    int i,j;	
    if(detail==0){	
        for(i=0;i<STATIONNUM;i++){	
            printf("--------------------\n");	
            printf("%s駅 (%d,%d)\n",stations[i].name,
            stations[i].x,stations[i].y);	
            printf("独占フラグ : %d   物件数 : %d\n",stations[i].ismonopoly,
            stations[i].propertynum);	
            for(j=0;j<stations[i].propertynum;j++){	
                printf("%s %d %d %d\n",stations[i].plist[j].name,
                stations[i].plist[j].price,stations[i].plist[j].earnings,
                stations[i].plist[j].holder);	
            }	
            printf("--------------------\n\n");	
        }	
        }else{	
        printf("--------------------\n");	
        printf("%s駅 (%d,%d)\n",stations[detail-1].name,stations[detail-1].x,
        stations[detail-1].y);	
        printf("独占フラグ : %d   物件数 : %d\n",stations[detail-1].ismonopoly,
        stations[detail-1].propertynum);	
        for(j=0;j<stations[detail-1].propertynum;j++){	
            printf("%s %d %d %d\n",stations[detail-1].plist[j].name,
            stations[detail-1].plist[j].price,stations[detail-1].plist[j].earnings,
            stations[detail-1].plist[j].holder);	
        }	
        printf("--------------------\n\n");     	
    }	
}
\end{lstlisting}

構造体の初期化が正確に行われていることを確認する.まず,playerstatus構造体について確認する.
初期化が正しく行えていれば,座標は(416,224),所持金は10000,それ以外のメンバには0が代入されているはずである.
リスト\ref{dispPlayerResult}にリスト\ref{main}を実行したときのコンソール画面を示す.
リスト\ref{dispPlayerResult}から全ての社長についてメンバに代入されている値が正しいことが確認できる.
これよりInitPlayer関数でplayerstatus構造体の初期化が正しく行えていることが確認できた.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=dispPlayerResult,caption=dispPlayer関数の実行結果]
--------------------
llpureiiyallms1社長 (416,224)

所持金 : 10000
総資産 : 0
カード枚数 : 0
0 0 0 0 0
--------------------

--------------------
llpureiiyallms2社長 (416,224)

所持金 : 10000
総資産 : 0
カード枚数 : 0
0 0 0 0 0
--------------------

--------------------
llpureiiyallms3社長 (416,224)

所持金 : 10000
総資産 : 0
カード枚数 : 0
0 0 0 0 0 
--------------------
    \end{lstlisting}

    次にstationstatus構造体およびpropertystatus構造体の初期化が正確に行えていることを確認する.リスト\ref{dispStationResult}
    にリスト\ref{main}におけるdispStation関数の実行結果を示す.実行結果は行数が長いため,ここでは野沢温泉駅,長野駅,伊那駅の
    3つ駅における結果を表示している.また,実行結果が正しいかどうかは長野駅の場合について確認する.リスト\ref{dispStationResult}
    における長野県の情報はリスト\ref{propertytxt}およびリスト\ref{naganotxt}の長野駅の情報と一致している.このことから
    readStation関数およびreadProperty関数を用いて長野駅の情報を構造体に正確に代入できていることが確認できた.
    他の駅について筆者が読み込んだ内容と元ファイルの内容が一致していること確認した.これらより,構造体の初期化が正しく行えている
    ことが確認できた.
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=dispStationResult,caption=dispStation関数の実行結果]
--------------------
nozawaoonnsenn駅 (18,1)
独占フラグ : 0   物件数 : 6
nozawanaoyaki 3000 80 0
nozawanaoyaki 3000 80 0
nozawanaoyaki 3000 80 0
ooooyu 12000 5 0
llsukillmszilouu 40000 10 0
llsukillmszilouu 40000 10 0
--------------------

～省略～

--------------------
nagano駅 (13,7)
独占フラグ : 0   物件数 : 6
rinngoeenn 600 120 0
rinngoeenn 600 120 0
yawatayaiisogorouu 6000 20 0
llaaiisusukellmslltollzilouu 20000 3 0
zennkouuzi 110000 30 0
naganokouusenn 600000 1 0
--------------------

～省略～

--------------------
iina駅 (23,27)
独占フラグ : 0   物件数 : 3
rinngollpaiill 3000 75 0
bunnguiitouuge 30000 7 0
takatooozilouusi 130000 5 0
--------------------
    \end{lstlisting} 

    \subsection{ウィンドウサイズ変更への対応(Reshape関数)}
    ウィンドウサイズの変更に対する対応について説明する.本ゲームではウィンドウサイズは
    固定する仕様にしている.この処理を行うのがReshape関数である.リスト\ref{Reshape}にReshape関数
    のコードを示す.ウィンドウサイズを固定する処理は11行目で行っている.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=Reshape,caption=Reshape関数]
// ウィンドウサイズ変更時の処理
void Reshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluOrtho2D(0, w, 0, h);
    glScaled(1, -1, 1);
    glTranslated(0, -h, 0);
    //windowサイズ固定 
    glutReshapeWindow(InitWidth,InitHeight);
}
    \end{lstlisting} 
    
    \subsection{ゲームの進行状況管理}
    ゲームの進行状況管理について説明する.ゲームの進行状況はturnstatus, inflgという
    グローバル変数を用いて行っている. turnstatusはサイコロをふる,移動をするという進行状況の大きな変化を
    管理するための変数である. turnstatusの値と進行状況の関係は表\ref{turnstatus}を通りである.
    inflgはサイコロをふる,サイコロをとめる,結果のダイアログを表示する,という細かい進行状況を管理する変数である.\\ 
    　turnstatusの値による処理の分岐はDisplay関数で行っている.Display関数はリスト\ref{main}の33行目で
    画面再描画時に呼びされるコールバック関数として登録されている. そして100msおきにTimer関数で再描画を行うように
    命令することで,100msおきにDisplay関数が呼び出される.リスト\ref{Timer}にTimer関数のコードを示す.
    リスト\ref{Timer}の4行目のglutPostRedisplay関数が画面の再描画を行う命令をする関数である. 5行目の命令は
    Timer関数を再度コールバック関数に登録することで, 100msおきにTimer関数が実行されるようにしている.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=Timer,caption=Tiemr関数]
// 画面更新用タイマー
void Timer(int t)
{
    glutPostRedisplay();
    glutTimerFunc(RESHAPETIME, Timer, 0);
}
    \end{lstlisting} 

    Display関数を一定時間おきに呼び出す方法が分かったから, Display関数の処理について説明する.リスト\ref{Display}にDisplay関数の
    コードを示す.3行目および4行目ではターン中の社長を画面の中心に描画するための
    計算を行っている.6行目から34行目はturnstatusの値ごとに
    呼び出す関数を分け,表\ref{turnstatus}に示す進行状況別に関数を呼び出す処理を行っている. turnstatus=3および
    11～14は未使用である理由は,追加機能実装のための余地を残して開発を行っていたためである.
    呼び出している関数の内容については次節以降で述べる.

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=Display,caption=Display関数]
// ディスプレイ関数
void Display(void){
    tx = players[turn].x/IMGSIZE-CX; // 中央座標計算
    ty = players[turn].y/IMGSIZE-CY;
    glClear(GL_COLOR_BUFFER_BIT); // 描画クリア
    if(turnstatus==0){ // ゲーム初期化処理
        startgame();
    }else if(turnstatus==1){ // 目的地設定
        desisionDist();
    }else if(turnstatus==2){ // ターンのはじめ
        startTurn();
    }else if(turnstatus==3){ // 予備
        turnstatus++;
    }else if(turnstatus==4){ // サイコロをふる処理
        rollDice();
    }else if(turnstatus==5){ // マス移動
        moveMass();
    }else if(turnstatus==6){ // 条件分岐
        checkMass();
    }else if(turnstatus==7){ // 物件購入処理
        purchaseProperty();
    }else if(turnstatus==8){ // プラス駅の処理
        plusMass();
    }else if(turnstatus==9){ // マイナス駅の処理
        minusMass();
    }else if(turnstatus==10){ // カード駅の処理
        cardMass();
    }else if(turnstatus==15){ // 月別分岐
        endTurn();
    }else if(turnstatus==16){ // 決算月
        processKessan();
    }else if(turnstatus==17){ // 最終成績
        endgame();
    }
    glFlush();
}
    \end{lstlisting} 

    \begin{table}[H]
  \caption{変数turnstatusの意味}
\label{turnstatus}
\begin{center}
    \begin{tabular}{c|c}\hline
    値 & 進行状況 \\ \hline \hline
    0 & 変数の初期化とタイトルの表示 \\ 
    1 & 目的地の設定 \\
    2 & ターンのはじめの処理 \\
    3 & 未使用 \\
    4 & サイコロをふる処理 \\
    5 & マス移動の処理 \\
    6 & 停車した駅の判別と処理の分岐 \\
    7 & 物件購入の処理 \\
    8 & プラス駅の処理 \\
    9 & マイナス駅の処理 \\
    10 & カード駅の処理 \\
    15 & ターン終了の処理 \\
    16 & 決算の処理 \\
    17 & 最終成績およびゲーム終了処理 \\ \hline
    \end{tabular}
\end{center}
\end{table}

    \subsection{ゲームの初期化とタイトル画面の表示}
    ゲームの初期化とタイトル画面の表示について説明する.この処理はturnstatusが0のときの処理である.
    メイン関数(リスト\ref{main})の29行目および30行目で,グローバル変数turnstatusおよびinflgに0が代入されている.
    このため,メインループが始めると,Display関数(リスト\ref{Display})からstartgame関数がはじめに呼び出される.\\
    　リスト\ref{startgame}にstartgame関数のコードを示す. startgame関数の処理について説明する.
    inflg=0のとき,グローバル変数の初期化を行って,　inflgを1にする処理を行っている.
    グローバル変数monthおよびyearは年月管理を行うための変数であり,ゲームスタート時に「1年目4月」となる仕様はここで実装している.
    グローバル変数turnは現在誰のターンかを管理するための変数である.グローバル変数turnの値とターンの関係は表\ref{whoturn}の通りである.
    最初に行動する社長は「プレイヤー1社長」だから,変数turnには0を代入している. グローバル変数goalflgは目的地設定の際に表示する文字を
    変化させるための変数である.ゲームスタート時は値が0で,誰かが目的地に到着すると値が1になる.\\
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=startgame,caption=ゲームスタート時の処理]
// ゲーム開始時の処理
void startgame(void){
    if(inflg==0){
        Initvalue(); // 変数初期化
        month=4; // 4月にセット
        year=1; // 1年目にセット
        calseason(); // 季節計算
        turn=0; // プレイヤー1のターンにセット
        goalflg=0; // ゴールフラグ初期化
        inflg++;
    }else if(inflg==1){
        PutSprite(spimg[3],0,0,&spinfo[3],1);
    }else if(inflg==2){
        inflg=0;
        turnstatus=1;
    }
}
    \end{lstlisting} 

    \begin{table}[H]
        \caption{グローバル変数turnの意味}
      \label{whoturn}
      \begin{center}
          \begin{tabular}{c|c}\hline
           値 & 社長 \\ \hline \hline
            0 & 社長1 \\
            1 & 社長2 \\
            2 & 社長3 \\ \hline
          \end{tabular}
      \end{center}
      \end{table}

    Initvalue関数について説明する.リスト\ref{Initvalue}にInitvalue関数のコードを示す.
    keyboardflgはキーボード入力を受け付ける/受け付けないという管理を行うフラグである.キーを押し続けた場合に,
    画面表示がスキップされてしまうことを防ぐため,このような変数を導入している. 5行目から7行目で初期化を行っている
    dummyresult配列は,サイコロやプラス駅を代表とする一定時間で変化するランダムな値を画面に表示するときに用いる配列である.
    キー入力で乱数の生成を停止するときに,タイマーと再描画のタイミングによって画面の描画の内容と変数に代入される値が
    異なってしまう場合がある.このため,「ダミー」を用いて,実際の乱数の計算と画面に表示する乱数を扱う変数を分けることで,
    画面描画の内容と変数に代入される値の整合性をとっている. dummyresult配列はこのダミーの結果を保持する配列である.
    8行目のグローバル変数directionは行動中の社長の移動方向を保持する変数である.ここでは上下左右どの方向でもない-1に設定している.
    9行目のグローバル変数selectposは社長がカードや物件を選択するときに,どれを選択したかを保持するための変数である.
    ここでは初期値として-1に設定している.\\

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=Initvalue,caption=Initvalue関数]
// 変数初期化
void Initvalue(void){
    int i;
    keyboardflg=0;
    for(i=0;i<SAIKOROMAX;i++){
        dummyresult[i]=0;
    }
    direction=-1;
    selectpos=0;
}
    \end{lstlisting} 

    calseason関数の処理について説明する.リスト\ref{calseason}にcalseason関数のコードを示す.
    calseason関数は月を管理する変数monthから,季節を計算する関数である. calseason関数の内部ではグローバル変数seasonに季
    節を表す値を代入する処理を行っている.グローバル変数seasonの値と季節の対応は表\ref{whoseason}の通りである.\\
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=calseason,caption=calseason関数]
//季節番号を計算
// 0:春 3~5月
// 1:夏 6~8月
// 2:秋 9~11月
// 3:冬 12~2月
void calseason(void){
    if((3<=month)&&(month<=5)){
        season=0;
    }else if((6<=month)&&(month<=8)){
        season=1;
    }else if((9<=month)&&(month<=11)){
        season=2;
    }else{
        season=3;
    }
} 
    \end{lstlisting} 

   \begin{table}[H]
    \caption{グローバル変数seasonの意味}
  \label{whoseason}
  \begin{center}
      \begin{tabular}{c|c}\hline
       値 & 季節 \\ \hline \hline
       0 & 春 \\
       1 & 夏 \\ 
       2 & 秋 \\ 
       3 & 冬 \\ \hline
      \end{tabular}
  \end{center}
  \end{table}

    inflg=1のとき,図\ref{title}に示すタイトル画面を表示する処理を行っている.inflg=1の状態から
    inflg=2の状態に移るためにはキーボードのEキーの入力が必要である.画面表示ではタイトル画面から
    目的地の設定画面に移る処理に該当する.リスト\ref{startgamekey}にこれを実装しているkeyboard関数の抜粋, 
    keyboardTimer関数, isE関数の3つのコードを示す. keyboard関数全体は付録の「game.c」(リスト\ref{code2})を参照してほしい.
    keyboard関数はturnstatus=0のとき, Eキーの入力を受け取るとinflgをインクリメントする処理を行う.入力された
    キーがEであるかどうかはisE関数で判定している. isE関数(リスト\ref{startgamekey}の11行目から17行目)は引数として受け取った
    文字がEのとき1,それ以外では0を返す処理を行っている.Eキーかどうか判定する関数を作成したのは,本ゲームのほとんどの
    入力がEキーで完結するためである.\\
    　キーボードの入力の処理が完了すると一定時間キーボード入力を無視する処理を実装している.画面切り替えのほとんどはEキー
    が担当しているため, Eキーを長押しされると画面の描画が混沌としてしまう.これを防ぐために一定時間キーボード入力を無視する処理を実装している.
    この処理はkeyboard関数およびkeyboardTimer関数で実装している.キー入力の処理が完了した後,リスト\ref{startgamekey}の31行目でkeyboardflgを1にして,
    32行目でkeyboardTimer関数をコールバック関数として呼び出している.
    この場合は500ms後にkeyboardTimer関数が呼び出される. keyboardTimer関数の定義はリスト\ref{startgamekey}の2行目から6行目である.
    keyboardTimer関数はkeyboardflgを0にする処理を行っている. keyboard関数はkeyboardflgが1のとき,21行目に示すようにkeyboardflgが0のときのみキー入力に対する
    処理を行うため, keyboardTimer関数が呼び出されるまでの間にキー入力が行われても何もしない.これらによってキーボードの入力を一定時間
    無視する処理を実装している.\\
    　inflg=2のときは, inflgを0にリセットしてturnstatus=2,つまり目的地の設定を行う処理を行うようにセットしている.
    この処理によって,次にDisplay関数が実行されるときに,目的地の処理が行われる.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.7]{sp4.png}
        \caption{タイトル画面}
         \label{title}
        \end{figure}   
    
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=startgamekey,caption=キーボードの入力制御(ゲームスタート)]
//キーボード入力管理タイマー 
void keyboardTimer(int t)
{
    // キーボード入力ロックを解除
    keyboardflg=0;
}

// eを押したか判定
// 1: キーがE
// 0 : キーがEでない
int isE(unsigned char key){
    if(key=='e'){
        return 1;
    }else{
        return 0;
    }
}

void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    if(keyboardflg==0){ // キーボード入力がロックされていないとき
        if(turnstatus==0){ //タイトル
            if(isE(key)){
                inflg++;
            }
        }

        (中略)
        
        if(turnstatus!=5){
            keyboardflg=1; // キーボード入力ロック
            glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
    }
    }
}

    \end{lstlisting} 

    \subsection{目的地の設定処理}
    目的地の設定について説明する.この処理はturnstatus=1のときの処理である. Display関数(リスト\ref{Display})ではturnstatus=1のとき,desicionDist関数を実行している. 
    リスト\ref{desicionDist}にdesicionDist関数のコードを示す.また,turnstatus=1のときのキーボードの処理については
    タイトル画面と同様にEキーを押すとinflgがインクリメントされる仕組みになっている.このため,keyboard関数のコードは省略する.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=desicionDist,caption=desicionDist関数]
// 目的地決定処理
void desicionDist(void){
    char fname[150];
    PutSprite(spimg[2],0,0,&spinfo[2],1); // 背景表示
    if(inflg==0){
        if(goalflg==0){ // 初めて目的地をセットするとき
            // さいしょのもくてきちをきめます．
            // Eでルーレットをまわしてください．
            sprintf(fname,"saiisilonomokutekitiwokimemasumrxxxede
            llrullmsllrelttollwomawasitekudasaiimr");             
        }else if(goalflg==1){
            // つぎのもくてきちをきめます．
            // Eでルーレットをまわしてください．                
            sprintf(fname,"tuginomokutekitiwokimemasumrxxxedellru
            llmsllrelttollwomawasitekudasaiimr");                 
            }
        drawText(fname,11,225,InitWidth-22,42,0);
    }else if(inflg==1){ // 乱数生成用の設定
        dummynum=1;
        dummyresult[0]=0;
        range=STATIONNUM; // rangeを駅の数にセット
        randflg=1; // ダミータイマーロック解除
        //タイマー呼び出し
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg++;
    }else if(inflg==2){ // ダミーリザルトを表示
        drawString(stations[dummyresult[0]].name,0,InitWidth/2-80,105,1); 
        // Eでとめます．
        sprintf(fname,"xedetomemasumr");
        drawText(fname,11,225,InitWidth-22,42,0);             
    }else if(inflg==3){
        randflg=0; // タイマー停止
        randresult=rand()%range; // 結果を計算
        // 目的地の座標,名前を格納
        distination.x=stations[randresult].x;
        distination.y=stations[randresult].y;
        sprintf(distination.name,"%s",stations[randresult].name);
        inflg++;
    }else if(inflg==4){
        // 目的地を画面出力
        // もくてきちはhogeです.
        // Eをおしてください.
        sprintf(fname,"mokutekitiha%sdesumrxxxewooositekudasaiimr",distination.name);
        drawText(fname,11,225,InitWidth-22,42,0); 
        drawString(distination.name,0,InitWidth/2-80,105,1);  
    }else if(inflg==5){ // status更新
        inflg=0;
        if(goalflg==1){
            turnstatus=7;
        }else{
            turnstatus=2;
        }
    }
}
        \end{lstlisting} 
    
        desicionDist関数の処理について説明する.
        まず,inflgの値にかかわらず行われる処理について説明する.これは背景を表示する処理のことである.
        背景を表示する処理は4行目で行っている,表示される背景は図\ref{distback}に示すものである.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.7]{sp3.png}
            \caption{目的地設定画面の背景}
             \label{distback}
            \end{figure} 
        
        inflg=0のとき,目的地を決める趣旨のダイアログを表示する処理を行っている. 表示する文字はgoalflgによって異なる.
        goalflg=0,つまり初めて目的地を決めるときは図\ref{dist1}に示すように「さいしょのもくてきちをきめます.Eでルーレット
        をまわしてください.」というダイアログが表示される. inflg=1,つまり目的地の再設定が行われるときは図\ref{dist2}に示すように
        「つぎのもくてきちをきめます.Eでルーレットをまわしてください.」というダイアログが表示される. 

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{distflg0.eps}
            \caption{初めて目的地を設定する場合の表示}
             \label{dist1}
            \end{figure} 
        
        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{distflg1.eps}
            \caption{目的地を再設定する場合の表示}
             \label{dist2}
            \end{figure} 

        ダイアログの表示方法について説明する.リスト\ref{dialog}にダイアログを表示するための関数を示す.
        リスト\ref{dialog}にはdrawDialog関数とdrawText関数の2つの関数の定義が記述されている. drawDialog関数は引数として受け取った
        ダイアログの左上の座標(x,y)から幅width,高さheightのダイアログを表示する関数である.ダイアログの描画はOpenGLのプリミティブ(図形を簡単な図形に分割して描くこと)を
        用いて行っている.描画方法は, glBegin関数とglEnd関数の間にglVertex2i関数を用いて座標を必要な数だけ並べることで
        行う.並んだ図形の結び方はglBegin関数の引数として指定する.ここでは中を塗りつぶす四角形を描画する「GL\_QUADS」と,
        中を塗りつぶさない線を描画する「GL\_LINE\_LOOP」を用いている.ダイアログは3つの図形を組み合わせて表示している.
        1つ目はダイアログの背景になるペールオレンジの四角形である.これはリスト\ref{dialog}の4行目から9行目で描画している.
        2つめは外側の縁取り部分(茶色)である.これはリスト\ref{dialog}の12行目から18行目で描画している.
        3つめは内側の縁取り部分(茶色)である.これはリスト\ref{dialog}の21行目から26行目で描画している.\\
        　drawText関数はダイアログの生成と文字の表示を同時に行うための関数である.リスト\ref{dialog}では29行目から
        34行目である.drawText関数は引数として受け取った文字列stringをdrawDialog関数とdrawString関数を用いて描画する
        処理を行っている. drawText関数ではダイアログと文字列が被らないようにdrawString関数の引数として与える座標(x+5,y+5)のように
        することでダイアログと表示する文字列が被らないようにする処理も行っている. drawText関数を用いることで,ダイアログと文字を
        描画する座標を別々に計算してプログラムしなくても自動で文字の位置が調整されるため,画面にダイアログをだす頻度が多い本ゲームの開発を簡単にしている.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=dialog,caption=ダイアログ表示の実装]
// ダイアログを画面に描画
void drawDialog(int x,int y,int width,int height){
    // ダイアログの背景を描画
    glBegin(GL_QUADS);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();

    // 外側の四角を縁取り
    glColor3ub(139,69,19);
    glBegin(GL_LINE_LOOP);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();

    // 内側の四角を縁取り
    glBegin(GL_LINE_LOOP);
    glVertex2i(x+5,y+5);
    glVertex2i(x+5,y+height-5);
    glVertex2i(x+width-5,y+height-5);
    glVertex2i(x+width-5,y+5);
    glEnd();
}

// テキスト表示
void drawText(char *string,int x,int y,int width,int height,int color){
    glColor3ub(255,245,238);
    drawDialog(x,y,width,height);
    drawString(string,color,x+5,y+5,0.5);
}
        \end{lstlisting} 

        図\ref{dist1}および図\ref{dist2}の状態でEキーを押すとinflgがインクリメントされinflg=1の処理が行われる.
        inflg=1の処理は乱数生成のための変数準備とダミーの乱数生成関数の起動である.
        inflg=1のときの処理はリスト\ref{desicionDist}の18行目から26行目である. 10行目ではグローバル変数dummynumに1を
        代入している. dummynumはdummyresult配列からいくつ結果を取り出すかを示す変数である. ダミー乱数の生成は
        複数の乱数を同時に生成したい場合があるため, dummyresult配列からいくつ結果を取り出すかで管理している.
        21行目ではグローバル変数rangeに駅の数を代入している.変数rangeは乱数の生成範囲を指定する変数である.
        変数rangeに代入した値$M$,生成される乱数$x$とすると,乱数を生成する関数では$0 \leq x < M$の範囲の
        整数乱数が生成される.22行目ではグローバル変数randflgを1にすることでダミー乱数を生成するタイマーを起動する準備をしている.
        24行目では,ダミー乱数を生成するタイマーであるRandTimer関数をコールバック関数として登録する処理を行っている.\\
        　リスト\ref{RandTimer}にRandTimer関数のコードを示す. RandTimer関数の内部では, dummynum個の乱数を生成し,
        その結果をdummyresult配列に代入する処理を行っている.そして, randflgが1のときは再度RandTimer関数を呼び出す処理を行っている.
        定数RANDTIMEの値は100であるから,100msおきにRandTimer関数が呼び出される.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=RandTimer,caption=RandTimer関数]
// ダミー乱数を一定時間ごとに生成するタイマー
void RandTimer(int t)
{ // (0,range-1)の範囲の乱数を生成
    int i;
    for(i=0;i<dummynum;i++){
        dummyresult[i] = rand()%range;
    }
    if(randflg==1){ // randflgがたっているときタイマー継続
        glutTimerFunc(RANDTIME, RandTimer, 0);
    }
}
        \end{lstlisting}
        　最後にinflgをインクリメントする処理を行っている(リスト\ref{desicionDist}の25行目).
        この処理によってinflg=1の処理は一回のみ行われ, inflg=2の処理が始まる.\\
        　次にinflg=2のときの処理について説明する. inflg=2のとき,生成したダミー乱数の結果を画面に出力する処理を行っている.
        図\ref{distrand1}および図\ref{distrand2}にinflg=2のときの画面表示を示す.図\ref{distrand1}および図\ref{distrand2}
        に示すように,目的地駅のダミー表示は100msおきにランダムに変化する.また,「Eでとめます.」というダイアログが表示される.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{distflg21.eps}
            \caption{ランダムな駅の表示例1}
             \label{distrand1}
            \end{figure} 

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{distflg22.eps}
            \caption{ランダムな駅の表示例2}
             \label{distrand2}
            \end{figure} 
        
            inflg=2の処理は,リスト\ref{desicionDist}では26行目から30行目である. inflg=2のとき,
            drawString関数およびdrawText関数を用いて,ダミー乱数のインデックスに該当する駅名と
            「Eでとめます.」というダイアログを表示している.\\
            　inflg=2からinflg=3への変化はキーボードのEキー入力によって行われる. inflg=3のときの処理は
            タイマーの停止とダミーでない本当の結果の計算である. リスト\ref{desicionDist}では31行目から38行目である.
            inflg=3の時の処理内容について説明する. 31行目で変数randflgを0にすることで乱数を生成するタイマーであるRandTimerが
            100msおきに呼び出される処理を停止している.これはRandTimer関数(リスト\ref{RandTimer})の8行目でrandflgが1のときに
            タイマーをコールバック関数として再登録しているためである. リスト\ref{desicionDist}の33行目では,結果として
            表示する乱数を生成しグローバル変数randresultに代入している.そして35行目から36行目で目的地の情報を保持するstationstatus
            型の変数distinationに,目的地の座標および名前を代入する処理を行っている. 最後にinflgをインクリメントすることでinflg=3の
            処理が1度だけ実行され,inflg=4の処理に移るようにしている.\\
            　inflg=4のときの処理について説明する. inflg=4のときの処理は, inflg=3で計算して結果を画面に表示することである.これによって
            目指すべき目的地が画面に表示される.図\ref{distflg4}がinflg=4のときの画面表示の例である. 図\ref{distflg4}から読み取れるように
            inflg=4のときは,画面に目的地とダイアログが表示される. リスト\ref{desicionDist}におけるinflg=4の処理は39行目から45行目である.
            inflg=4のとき, drawText関数で「もくてきちはhogeです.Eをおしてください.」というダイアログを表示し,drawString関数で
            目的地名を表示する処理を行っている.

            \begin{figure}[H]
                \centering
                \includegraphics[scale=1.3]{distflg4.eps}
                \caption{目的地の決定}
                 \label{distflg4}
                \end{figure} 

            最後にinflg=5のときの処理について説明する. inflg=4からinflg=5への変化はEキー入力の入力によって行われる.
            リスト\ref{desicionDist}では46行目から53行目である.
            目的地を設定した後の処理は2通りある.初めての目的地設定の場合は, turnstatus=2,つまりターンのはじめの処理が
            行われるようにturnstatusを更新している. 2回目以降の目的地の設定の場合,turnstatus=7,つまり物件の購入処理が行われるようにturnstatusを更新
            している.この処理を行っているのが48行目から52行目である. 目的地の設定が初めてかどうかはグローバル変数goalflgが管理しているから,変数goalflgの値に
            よってturnstatusを変更する処理を行っている. これらの処理によって目的地の設定を行っている.

    \subsection{プレイヤーおよびマップの描画処理}
    プレイヤーおよびマップの描画処理について説明する. これらの処理はturnstatusが2,4,5,6,7,8,9,10で共通する処理である.
    まず,マップの描画について説明する. マップの描画はリスト\ref{drawMap}に示すdrawMap関数で行っている. マップは図\ref{map}に示したように
    マップのサイズは960$\times$960のサイズである.これに対して,ウィンドウのサイズは480$\times$320であるため,マップ全体をウィンドウに表示することは
    できない.そこで,ターン中の社長を画面の中心に描画し,マップは社長を中心にウィンドウにおさまる範囲を描画する仕様にした.\\
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=drawMap,caption=drawMap関数]
// マップを描画
void drawMap(void){
    int x,y;
    int drawx,drawy;
    int img_num;
    for(y=0;y<InitHeight/IMGSIZE;y++){
        for(x=0;x<InitWidth/IMGSIZE;x++){
            drawx = x*IMGSIZE;
            drawy = y*IMGSIZE;
            img_num = getmapnum(x+tx,y+ty);
            if((distination.x==x+tx)&&(distination.y==y+ty)){ // 目的地のとき
                // 目的地画像を描画
                PutSprite(mapimg[DIST], drawx, drawy, &mapinfo[DIST],1);
            }else if(img_num==WALL){ // 草原マップのとき
                // 季節にあった草原を描画
                PutSprite(seasonimg[season], drawx, drawy, &seasoninfo[season],1);
            }else{
                // マップ描画
                PutSprite(mapimg[img_num], drawx, drawy, &mapinfo[img_num],1);
            }
        }
    }
}
        \end{lstlisting}

        実際の処理について説明する.まず,ターン中の社長の座標から,図\ref{mapdesc}に示すマップの左上となるMap配列のインデックス(tx,ty)を計算する.
        この値は別の関数でも仕様するため, Display関数のリスト\ref{Display}の3行目および4行目で行っている. 定数CXは7,CYは5になっている.
        このため,ターン中の社長のインデックス(x,y)から(CX,CY)を引くことで,ターン中の社長を中心としたときの
        画面左上のMap配列におけるインデックスが計算できる.drawMap関数では
        2重のfor文を用いてマップの描画を行っている. for文内の処理について説明する.リスト\ref{drawMap}の8行目および9行目では実際に
        描画する座標(drawx,drawy)を計算している.画像のサイズは32$\times$32に統一しているため,画像サイズを表す定数(IMGSIZE=32)をインデックス計算の
        ための座標(x,y)にかけることで実際の座標が計算できる.10行目では, Map配列から描画する画像の種類を取得している. リスト\ref{getmapnum}に
        getmapnum関数の定義と, getmapnum関数内に登場する定数を示す. getmapnum関数では,引数として与えたインデックス(x,y)
        がどの種類のマスかを返す処理を行っている. 15行目から18行目では配列の添え字をはみ出したときの処理を行っている.
        配列の処理をはみ出した引数を指定した場合,背景の番号を返すように設定している.リスト\ref{drawMap}ではgetmapnum関数に
        インデックス(x+tx,y+ty)を与えることで,インデックスが(tx,ty)だけずれ,ターン中の社長を中心に表示するようにMap配列から
        　描画する部分の画像情報を取り出している.\\
        表示する画像の種類を取得できたから,画像の表示を行う.リスト\ref{drawMap}では11行目から20行目の処理である.
        11行目から13行目は,例外処理として目的地駅のときに目的地駅の画像を表示する処理を行っている.14行目から16行目では
        表示する画像が背景のときの処理を行っている.背景は季節に合わせたものを表示する必要があるため,変数seasonを
        季節別の画像を格納しているseasonimg配列に渡して描画している.17行目から20行目では目的地および背景以外の
        ときの画像の描画を行っている.これらの処理によってマップを描画している.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=2.7]{mapdesc.eps}
            \caption{マップの描画方法}
             \label{mapdesc}
            \end{figure} 

        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=getmapnum,caption=getmapnum関数]
// マスIDの定義
#define PLUSMASU 0 // プラス駅
#define MINUSMASU 1 // マイナス駅
#define CARDMASU 2 // カード駅
#define PROPERTYMASU 3 // 物件駅
#define SENRO1 4 // 線路(縦)
#define SENRO2 5 // 線路(横)
#define DIST 6 // 目的地駅
#define WALL 623 // 草原

// マップの画像番号を取得
int getmapnum(int x,int y){
    int img_num;
    // 配列番号をはみ出した場合
    if((x<0)||(x>=XMAX)){ 
        return 623; // 草原マップを返す
    }else if((y<0)||(y>=YMAX)){
        return 623; // 草原マップを返す
    }

    switch (Map[y][x]){
    case 'A': // 草原
        img_num=623;
        break;
    case 'B': // 物件
        img_num=3;
         break;
    case '|': // 線路(縦)
        img_num=4;
        break; 
    case '-': // 線路(横)
        img_num=5;
        break;
    case 'P': // プラス駅
        img_num=0;
        break;
    case 'M': // マイナス駅
        img_num=1;
        break;
    case 'C': // マイナス駅
        img_num=2;
        break;
    }
    return img_num;
}
        \end{lstlisting}

        次に社長の描画方法について説明する.リスト\ref{drawPlayer}に社長を画面に表示するための関数であるdrawPlayer関数の
        コードを示す. drawPlayer関数の内部処理について説明する. drawPlayer関数はターン中ではない社長を先に描画してから,
        ターン中の社長を描画する処理を行っている.ターン中の社長を最前面に描画しないと,行動中にマップのどこにいるか分からなくなって
        しまうため,このような仕様にしている.ターン中ではない社長の描画はリスト\ref{drawPlayer}の6行目から14行目で行っている. 
        ターン中の社長かどうかは7行目のif文で判定している.ターン中の社長出ない場合は,表示する座標を計算しPutSprite関数で描画を行っている.
        ターン中の社長の描画はリスト\ref{drawPlayer}の15行目で行っている.座標(CENTX,CNETY)は画面中心のインデックス(CX,CY)を画像サイズIMGSIZE倍した
        値である.これによって,ターン中の社長が常に画面中心に描画される.

        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=drawPlayer,caption=drawPlayer関数]
// プレイヤーを描画
// 最上面にターン中のプレイヤーを描画
void drawPlayer(void){
    int transx,transy;
    int i;
    for(i=0;i<PLAYERNUM;i++){
        if(i!=turn){ // ターン中のプレイヤー以外を描画
            transx = players[i].x/IMGSIZE;
            transy = players[i].y/IMGSIZE;
            PutSprite(playerimg[i], (transx-tx)*IMGSIZE,
            (transy-ty)*IMGSIZE, &playerinfo[i],1);
        }
    }
    // ターン中のプレイヤーを最上レイヤーに表示
    PutSprite(playerimg[turn], CENTX,CENTY, &playerinfo[turn],1);
}
        \end{lstlisting}

        実際の動作について確認する.ここでは,次の3つの動作について確認する.
        \begin{enumerate}
            \item マップおよび社長が表示されるか
            \item 社長が移動したときの動作
            \item マップ端の動作
        \end{enumerate}
    
    まず,マップおよび社長が表示されるかを確認する.ここでは,ダイアログを代表とするマップと社長以外の
    表示が少ないturnstatus=5のマス移動を例に説明する.図\ref{mapplay1}にturnstatus=5のときの画面表示の例を示す.
    図\ref{mapplay1}の状況は,全社長が長野駅におり,行動中の社長はプレイヤー1社長である. レポートでは白黒のため伝わらないが,
    プレイヤー1社長が最前面に描画されている.このことから,ターン中の社長が最前面に表示される処理が正確に行えていることが確認できる.
    さらに図\ref{mapplay1}からターン中の社長が画面の中心に描画されており,マップは社長を中心に描画されていることがわかる.
    これより,社長を画面中心,マップを社長を中心に画面範囲で描画できていることが確認できる.

            \begin{figure}[H]
                \centering
                \includegraphics[scale=1.3]{mapplay1.eps}
                \caption{マップおよび社長の表示}
                 \label{mapplay1}
                \end{figure} 

    次に社長が移動したときの動作について確認する.ターン中の社長が移動すると,ターン中の社長を中心に描画したまま,
    マップの表示が変わることを確認する.図\ref{mapplay2}に社長が移動したときの画面表示を示す.図\ref{mapplay2}は
    図\ref{mapplay1}から左に128px移動した状態である.図\ref{mapplay2}から,社長が移動した場合も,
    社長が中心に表示され,マップは社長を中心に描画されることがわかる.
    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{maplay2.eps}
        \caption{社長が移動したときの画面表}
         \label{mapplay2}
        \end{figure} 

    最後にマップ端の動作を確認する.社長の位置によっては,マップの描画位置はMap配列の定義されている領域をはみ出す場合ある.
    この場合に背景が表示されることを確認する.図\ref{mapplay3}にプレイヤー1社長がマップ端の表示される位置に移動したときの
    画面表示を示す.図\ref{mapplay3}のプレイヤー1社長のMap配列におけるインデックスは(3,7)である.社長を中心に描画しようとすると
    画面表示の左上のMap配列におけるインデックスは(-4,2)であるため添え字をはみ出している.図\ref{mapplay3}から,添え字がはみ出している
    場合に背景が表示されていることが確認できる.これらから,ターン中の社長を中心に描画する処理と,マップをターン中の社長を中心に画面におさまる
    範囲で描画する処理について確認できた.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{maplay3.eps}
        \caption{マップ端の表示}
         \label{mapplay3}
        \end{figure} 
    
    \subsection{ターンのはじめの処理}
    ターンのはじめの処理について説明する.この処理はturnstatus=2のときの処理である.     
    Display関数(リスト\ref{Display})ではturnstatusが2のときに,startTurn関数を呼び出している.リスト\ref{startTurn}にstartTurn関数のコードを示す.
    startTurn関数の処理を,実際の動作を交えて説明する. startTurn関数の処理において,inflgの状態に関係なく実行される処理は,
    drawMap関数とdrawPlayer関数である.これらによってマップおよび社長の画像が画面に表示される. drawMap関数とdrawPlayer関数は
    次節以降でも登場するが,使用方法は同じであるため説明は省略する.\\
    　次にinflg=0のときの処理について説明する.リスト\ref{startTurn}では7行目から12行目である.
    inflg=0のときグローバル変数の初期化を行っている. グローバル変数saikoroは
    振るサイコロの数を制御するための変数である.サイコロは通常1個のみ振るが,カードの効果によって最大4個まで振ることができる仕様になっている.
    ここでは,サイコロの数を1に設定している. 11行目ではグローバル変数selectposに0を代入している.変数selectposはユーザーが選択を行う場面で
    今どれを選択しているのかを示す変数である. 変数の初期化が終了すると,12行目でinflgをインクリメントしてinflg=0の状態からinflg=1
    の状態に変化させている.\\
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=startTurn,caption=startTurn関数]
// ターン開始時の処理
void startTurn(void){
    int i;
    char fname[150];
    drawMap(); // マップ描画
    drawPlayer(); // プレイヤー描画
    if(inflg==0){
        saikoro=1;
        dummynum=1;
        keyboardflg=0;
        selectpos=0;
        inflg++;
    }else if(inflg==1){
        // プレイヤーカラーでダイアログ生成
        glColor3ub(playercolor[turn][0],playercolor[turn][1],playercolor[turn][2]);
        drawDialog(11,11,InitWidth-22,34+16);
        // hogeねんめ hugaがつ
        sprintf(fname,"%dnennmess%dgatu",year,month);
        drawString(fname,0,16,11+8,0.5);
        // 所持金表示
        drawMoney(players[turn].money,InitWidth/2,11+8+16,0,0.5);
        // hogeしゃちょう
        sprintf(fname,"%ssilatilouussssss",players[turn].name);
        drawString(fname,0,16,11+8+16,0.5);   
        // サイコロ
        // カード
        sprintf(fname,"llsaiikoroxxkallmslldoll");
        drawDialog(11,175,74,42);
        // セレクトポジション表示
        if(selectpos == 0){
            glColor3ub(255,0,0);
            drawQUAD(16,180,64,16);                 
        }else if(selectpos==1){
            glColor3ub(255,0,0);
            drawQUAD(16,196,64,16);               
        }   
        drawString(fname,0,16,180,0.5);
        // hogeしゃちょうのばんです．
        sprintf(fname,"%ssilatilouunobanndesumr",players[turn].name);
        drawText(fname,11,225,InitWidth-22,42,0);      
    }else if(inflg==2){
        if(selectpos==0){
            inflg++;
        }else{
            if(players[turn].cardnum==0){
                inflg=4;
            }else{
                selectpos=0;
                inflg=5;
            }
        }
    }else if(inflg==3){ // status更新(サイコロをふる)
        inflg=0;
        turnstatus++;
    }else if(inflg==4){ // カードがないとき
        sprintf(fname,"llkallmslldollga1maiimoaarimasennmr");
        drawText(fname,11,225,InitWidth-22,42,0);               
    }else if(inflg==5){
        glColor3ub(255,245,238);
        drawDialog(155,50,10+10*16,10+16*(players[turn].cardnum+1));
        // セレクトポジション表示
        glColor3ub(255,0,0);
        drawQUAD(160,55+selectpos*16,10*16,16);                 
        
        for(i=0;i<players[turn].cardnum;i++){
            if(players[turn].card[i]!=0){
                drawString(cardname[players[turn].card[i]-1],0,160,55+i*16,0.5);                   
            }
        }
        drawString("modoru",0,160,55+players[turn].cardnum*16,0.5);
    }else if(inflg==6){
        if(selectpos==players[turn].cardnum){ // もどるのとき
            selectpos=0;
            inflg=1;
        }else{
            rcard = cardprocess(players[turn].card[selectpos]);
            inflg++;
        }
    }else if(inflg==7){
        if(rcard==0){
            // こうげきがかわされた.
            sprintf(fname,"kouugekigakawasaretamr");
            nextflg=1;
        }else if(players[turn].card[selectpos]==KYUKO){
            // サイコロが2つになった.
            sprintf(fname,"llsaiikorollga2tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==TOKKYU){
            // サイコロが3つになった.
            sprintf(fname,"llsaiikorollga3tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==SINKANSEN){
            // サイコロが4つになった.
            sprintf(fname,"llsaiikorollga4tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==SAMMIT){
            // ぜんしゃちょうがhogeしゃちょうのもとにあつまった.
            sprintf(fname,"zennsilatilouuga%ssilatilouunomotoniaatumalttamr",
            players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==BUTTOBI){
            // hogeしゃちょうはいったいどこへ.
            sprintf(fname,"%ssilatilouuhaiilttaiidokohe",players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==JUOKU){
            // hogeしゃちょうにプラス10億円.
            sprintf(fname,"%ssilatilouunillpurasull10oxexmr",players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==TOKUSEIREI){
            // ぜんしゃちょうのしゃっきんがちょうけしになった.
            sprintf(fname,"zennsilatilouunosilaltkinngatilouukesininalttamr");
            nextflg=1;
        }else if(players[turn].card[selectpos]==GOUSOKKYU){
            // ほかのちゃちょうのカードがなくなった.
            sprintf(fname,"hokanosilatilouunollkallmslldollganakunalttamr");
            nextflg=1;
        }
        drawText(fname,11,225,InitWidth-22,42,0);      
    }else if(inflg==8){ // 
        // 使ったカードの消去
        for(i=selectpos;i<players[turn].cardnum-1;i++){
            players[turn].card[i]=players[turn].card[i+1];
        }
        players[turn].cardnum--;
        inflg=0;
        if(nextflg==1){
            turnstatus=15; // ターン終了 
        }else{
            turnstatus++; // サイコロをふる処理
        }     
    }
}
        \end{lstlisting}    

    inflg=1およびinflg=2のときの処理について説明する. 社長のターンが始まると図\ref{st2p1}および図\ref{st2p2}に示すような画面表示が行われる.
    図\ref{st2p1}はプレイヤー1社長の場合,図\ref{st2p2}はプレイヤー2社長の場合の画面である.図\ref{st2p1}から,ターンのはじめに
    は年月および所持金を表示するダイアログ,サイコロとカードのどちらを使用するか選択するダイアログ,「(社長名)しゃちょうのばんです.」という
    表示を行うダイアログの3つが表示されることがわかる.また,図\ref{st2p1}および図\ref{st2p2}の画面では,「W」および
    「S」キーで,サイコロとカードの選択を示す赤い四角形の位置を変化させることができる.これをセレクトポジションと
    呼ぶことにする.セレクトポジションはデフォルトで「サイコロ」になっており,「S」キーを押すと,図\ref{st2p3}に示す
    ように「カード」が選択された状態になる. 「カード」を選択した状態で「W」キーを押すと「サイコロ」を選択した状態になる.
    どちらかを選択した状態で「E」を押した場合はturnsatusが変化するから,この場合の処理の説明は後で行う.
    これらを実装しているのがinflg=1およびinflg=2のときの処理である.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{st2p1.eps}
        \caption{ターンのはじめの画面(プレイヤー1社長)}
         \label{st2p1}
        \end{figure} 

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{st2p2.eps}
            \caption{ターンのはじめの画面(プレイヤー2社長)}
             \label{st2p2}
            \end{figure}   

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{st2p3.eps}
            \caption{カードを選択した状態}
             \label{st2p3}
            \end{figure}   
        
        ダイアログおよびセレクトポジションの処理を実装するコードについて説明する.リスト\ref{startTurn}では13行目から51行目である.
        inflgが1のとき,画面に先述した3つのダイアログを表示する処理を行っている.年月および所持金を表示するダイアログは15行目から
        21行目,サイコロとカードのどちらを使用するか選択するダイアログは27行目から37行目,「(社長名)しゃちょうのばんです.」という
        表示を行うダイアログは39行目および40行目である.セレクトポジションはグローバル変数selectposで管理している. selectposは
        グローバル変数であるから,「W」または「S」のキーの入力があったときにkeyboard関数でselectposの値を変更する処理を行っている.
        リスト\ref{keyboardstatus2}にkeyboard関数におけるturnstatus=2のときの処理を示す. selectposの値を操作しているのは
        リスト\ref{keyboardstatus2}の9行目から20行目である. 9行目ではinflgが1かどうか判定を行っている.これは,turnstatus=1のときの
        他のキーボード入力処理と区別するためである.10行目から17行目は押されたキーが「W」または「S」のキーかどうかを判定し
        selectposを変更する処理を行っている. selectpos=0のとき「サイコロ」,1のとき「カード」になる仕様になっている.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=keyboardstatus2,caption=ターンのはじめのキーボード入力の処理]
// キーボード入力管理
void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
if(keyboardflg==0){ // キーボード入力がロックされていないとき
    (省略)
    }else if(turnstatus==2){ // ターンのはじめ
    if(inflg==1){
        if(key=='w'){
            if(selectpos==1){
                selectpos=0;
            }   
        }else if(key=='s'){
            if(selectpos==0){
                selectpos=1;
            }
        }else if(isE(key)){
            inflg++;
        }
    }else if(inflg==4){
        if(isE(key)){
            inflg=1;
        }        
    }else if(inflg==5){
        if(key=='w'){
            if(selectpos>=1){
                selectpos--;
            }   
        }else if(key=='s'){
            if(selectpos<players[turn].cardnum){
                selectpos++;
            }
        }else if(isE(key)){
            inflg++;
        }        
    }else{
        if(isE(key)){
            inflg++;
        }        
    }
    }
    (省略)

    if(turnstatus!=5){
        keyboardflg=1; // キーボード入力ロック
        glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
    }
}
}
        \end{lstlisting}   

        keyboard関数でselectposの値を操作することで,リスト\ref{startTurn}の30行目のif文の真偽が変化し,どちらを選択しているか
        示すための赤い四角形を描画している.赤い四角形はdrawQUAD関数で描画している.リスト\ref{drawQUAD}にdrawQUAD関数の定義を示す.
        drawQUADは引数として,四角形を描画する左上の座標(x,y)および四角形の幅width,高さheightを受け取る.内部では,プリミティブを
        用いた描画を行うOpenGLの関数を用いて四角形の描画を行っている.

        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=drawQUAD,caption=drawQUAD関数]
// 四角形を描画
void drawQUAD(int x,int y,int width,int height){
    glBegin(GL_QUADS);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();       
}
        \end{lstlisting}   
        　inflg=1の状態からinflg2の状態になる処理は, リスト\ref{keyboardstatus2}の18行目から20行目に示すようにEキーの
        入力によるinflgのインクリメントによって行っている.inflgが2のときの処理(リスト\ref{startTurn}の41行目から51行目)は,
        Eキーを押したときのセレクトポジションによって処理を分岐する処理である. セレクトポジションが「サイコロ」,つまりselectpos=0
        の場合はinflgを3にしている. セレクトポジションが「カード」,つまりselectposが1の場合はカード枚数を確認し,
        カード枚数が0のときinflgを4,そうでないときはinflgを5にしている.\\
        　inflg=3のときの処理について説明する.リスト\ref{startTurn}では52行目から54行目である.
        inflgが3のときの処理はサイコロを振る処理にturnstatusの値を変更することである.turnstatus=3は未使用であるが,
        ここではturnstatusをインクリメントする処理を行っている.\\
        　inflg=4のときの処理を説明する. inflg=4の処理はカードが1枚もないときに,「カード」が選択された時の処理である.
        この場合,図\ref{nocard}に示すように「カードが1まいもありません.」と画面に表示される.リスト\ref{startTurn}では55行目から57行目である. 
        図\ref{nocard}の状態で,Eキーを押すとリスト\ref{keyboardstatus2}の21行目から24行目に示す処理によってinflg=1,つまり図\ref{st2p1}
        に示す画面に戻る.

     \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{st2fl4.eps}
        \caption{カードが1枚もないときのカード表示}
         \label{nocard}
        \end{figure}        

        最後に,inflgが5～8のときの処理について説明する. inflgが5～8のときの処理は図\ref{st2p1}で「カード」を選択したときの処理である.
        カードを持っている場合に「カード」を選択すると図\ref{havecard}に示すように,手持ちのカードが表示される.図\ref{havecard}の例では
        「サミットカード」,「とっきゅうカード」,「ごうそっきゅうカード」の3種類を持っている.また,一番下のセレクトポジションには「もどる」
        という項目がある.いずれかのカードを選択した状態でEキーを押すと,カードが使用される.「もどる」を選択してEキーを押すと
        図\ref{st2p1}の画面に戻る.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{havacard.eps}
            \caption{手持ちのカードの表示}
             \label{havecard}
            \end{figure}   
        
        これらがinflgが5～8のときの処理である.リスト\ref{startTurn}では58行目から122行目である.
        「カード」が選択されるとまずinflg=5の処理が行われる. リスト\ref{startTurn}では58行目から70行目である. 
        inflg=5の処理は,手持ちのカード,「もどる」,セレクトポジション
        の3つ画面に表示する処理である.手持ちのカードはplayerstatus型の配列playersのメンバcardが保持しているから,drawString関数で
        これを表示している. inflg=5でのセレクトポジションの処理はリスト\ref{keyboardstatus2}の25行目から41行目に記述されている.
        セレクトポジションの移動処理は「カード」,「サイコロ」を選択するときの処理と同じであるため,説明は省略する.\\
        　カードを選択してEキーを押すとinflg=6の処理が行われる. リスト\ref{startTurn}では71行目から78行目である. 
        ターン中の社長のカード枚数$c$とすると, selectposの値sが$0 \leq s \leq c-1$ のときは,所持しているカードのいずれかが
        選択されているため,カードの効果を発動する関数であるcardprocess関数を実行している.変数selectposの値がターン中の社長のカード枚数と
        等しいとき,「もどる」が選択されているためinflg=1,つまり図\ref{st2p1}の画面に戻るようにしている.\\
        　カードの効果を発動する関数である
        cardprocess関数について説明する.リスト\ref{cardprocess}にcardprocess関数のコードを示す. cardprocess関数は引数として
        効果を発動するカードの番号を受け取る.また,返り値としてカードの発動が成功した場合に1,失敗した場合に0を返す.カードの番号と発動するカードはリスト\ref{cardprocess}の2行目から10行目のようになっている.
        各カードの処理について説明する.発動するカードが,急行カード,特急カード,新幹線カードのいずれかのときサイコロの数を管理するグローバル変数saikoro
        の値を更新する処理を行っている.サイコロの数は急行カードのときは2個,特急カードのときは3個,新幹線カードのときは4個にしている.\\
        　サミットカードの場合は,成功または失敗の計算をしたのちに,カードの効果を発動している.確率$\frac{2}{3}$で成功するために,乱数を生成して
        3で割った値が0でないときにカードの効果を発動するようにしている.サミットカードの効果は,すべての社長をターン中の社長の駅に集める効果
        であるから,全ての社長の座標をターン中の社長の座標で上書きする処理を行っている.ぶっとびカードの効果は社長をランダムな物件駅に飛ばす効果であるから,物件駅の数を表す定数STATIONNUMで乱数をわることで,
        ランダムな駅のインデックスを取得している.そして,取得したインデックスに該当する物件駅の座標をstations構造体から取得して
        画像サイズIMGISIZE倍することで,新しい座標が計算される.この座標をターン中の社長の座標に代入することで,ランダムな駅へぶっとぶ
        効果を実装している. 10億円カードは使用すると10億円が手に入るカードであった.10億円カードの時の処理は,ターン中の社長の
        moneyをプラス100000する処理ことでおこなっている.徳政令カードは借金を負っている社長の所持金を0にするカードであった.このため,全ての社長について所持金を保持するメンバmoneyが
        0よりも小さいか判定し,0よりも小さい場合はメンバmoneyを0にする処理を行っている.剛速球カードは確率$\frac{1}{2}$で成功し,他の社長のカードを全て破棄するカードであった.このため,生成した乱数を2で割り0のとき
        はターン中の社長以外のカード配列およびカード枚数を0で埋める処理を行っている.これらの処理によってカードの効果を実装している.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=cardprocess,caption=cardprocess関数]
// カード番号の定義
#define KYUKO 1 // 急行カード
#define TOKKYU 2 // 特急カード
#define SINKANSEN 3 // 新幹線カード
#define SAMMIT 4 // サミットカード 
#define BUTTOBI 5 // ぶっとびカード
#define JUOKU 6 // 十億円カード
#define TOKUSEIREI 7 // 徳政令カード
#define GOUSOKKYU 8 // 剛速球カード

// カード処理
int cardprocess(int num){
    int r=1;
    int i,j,randst;
    if(num==KYUKO){ // 急行カード
        saikoro=2;
    }else if(num==TOKKYU){ // 特急カード
        saikoro=3;
    }else if(num==SINKANSEN){ // 新幹線カード
        saikoro=4;
    }else if(num==SAMMIT){ // サミットカード
        if(rand()%3!=0){
            for(i=0;i<PLAYERNUM;i++){
                players[i].x=players[turn].x;
                players[i].y=players[turn].y;
            }
        }else{
            r=0;
        }
    }else if(num==BUTTOBI){ // ぶっとびカード
        randst = rand()%STATIONNUM;
        players[turn].x = stations[randst].x*IMGSIZE;
        players[turn].y = stations[randst].y*IMGSIZE;
    }else if(num==JUOKU){ // 10億円カード
        players[turn].money+=100000;
    }else if(num==TOKUSEIREI){ // 徳政令カード
        for(i=0;i<PLAYERNUM;i++){
            if(players[i].money<0){
                players[i].money=0;
            }
        }
    }else if(num==GOUSOKKYU){ // 剛速球カード
        if(rand()%2){
        for(i=0;i<PLAYERNUM;i++){
            if(i!=turn){
                players[i].cardnum=0;
                for(j=0;j<CARDMAX;j++){
                    players[i].card[j]=0;
                }
            }
        }
        }else{
           r=0; 
        }        
    }
    dummynum=saikoro;
    return r;
}
        \end{lstlisting}   
        　カードの発動の成功/失敗はリスト\ref{startTurn}の76行目に示すように変数rcardに保存される.
        カードの処理が終了すると,リスト\ref{startTurn}の77行目に示すように, inflgがインクリメントされinflg=7の処理が行われる.
        inflg=7のときの処理について説明する. inflg=7の処理はカードを使用した結果を画面に表示する処理である. 
        図\ref{c1}～図\ref{c9}に各カードを使用したときの画面表示を示す.図\ref{c1}～図\ref{c8}はカードの使用に成功した場合,
        図\ref{c9}はカードの使用に失敗した場合である.使用したカードによって表示する内容が変化する処理はリスト\ref{startTurn}の
        80行目から117行目に記述されている.また,グローバル変数nextflgの値を急行カード,特急カード,新幹線カードのいずれかのカードのとき0,
        それ以外のカードのとき1になるようにする処理を行っている.急行カード,特急カード,新幹線カードの3つのカードはカードを使用した
        後にサイコロを振るため,変数nextflgを使用して,使用したカードの判別を行っている.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{kyukou.eps}
            \caption{急行カードを使用したときの表示}
             \label{c1}
            \end{figure}   

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{tokkyu.eps}
            \caption{特急カードを使用したときの表示}
             \label{c2}
            \end{figure}  

            \begin{figure}[H]
                \centering
                \includegraphics[scale=1.3]{sinkansen.eps}
                \caption{新幹線カードを使用したときの表示}
                 \label{c3}
                \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{samitto.eps}
            \caption{サミットカードを使用したときの表示}
             \label{c4}
            \end{figure}
            
        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{buttobi.eps}
            \caption{ぶっとびカードを使用したときの表示}
             \label{c5}
            \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{tenoku.eps}
            \caption{10億円カードを使用したときの表示}
             \label{c6}
            \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{tokuseirei.eps}
            \caption{徳政令カードを使用したときの表示}
             \label{c7}
            \end{figure}

            \begin{figure}[H]
                \centering
                \includegraphics[scale=1.3]{kyu.eps}
                \caption{剛速球カードを使用したときの表示}
                 \label{c8}
                \end{figure}

                \begin{figure}[H]
                \centering
                \includegraphics[scale=1.3]{hirari.eps}
                \caption{カード使用が失敗したときの表示}
                 \label{c9}
                \end{figure}

    使用したカードの種類別の画面出力が行われた状態でEキーを押すとinflg=7の状態からinflg=8の状態に変化する.
    inflg=8の処理は,使用したカードの消去とturnstatusの変化の処理である.リスト\ref{startTurn}では119行目から131行目である.
    カードの消去は121行目から124行目で行っている. turnstatusの変化の処理は126行目から130行目で行っている.
    nextflgが1のとき,サイコロを増やすカードが仕様されたことを示しているためturnstatusを4,つまりサイコロを振る処理にセットしている.
    nextflgが0のときはturnstatusを15,つまりターン終了処理にセットしている.これらの処理によってターンのはじめの処理を実装している.

    \subsection{サイコロをふる処理}
    サイコロを振る処理について説明する. これはturnstatus=4のときの処理である.
    Display関数(リスト\ref{Display})ではturnstatus=4のとき, rollDice関数を呼び出している.
    リスト\ref{rollDice}にrollDice関数のコードを示す.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=rollDice,caption=rollDice関数]
// サイコロをふる処理
void rollDice(void){
    int i;
    char fname[150];
    drawMap();
    drawPlayer();    
    if(inflg==0){
        // ダミーサイコロを起動
        for(i=0;i<SAIKOROMAX;i++){
            dummyresult[i]=0;
        }
        range=DICEMAX;
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg=1;
    }else if(inflg==1){
        // サイコロ描画
        for(i=0;i<dummynum;i++){
            PutSprite(diceimg[dummyresult[i]], 416, 32+32*i, &diceinfo[dummyresult[i]],1);
        }
        // Eでサイコロをとめます．
        sprintf(fname,"xedellsaiikorollwotomemasumr");
        drawText(fname,11,225,InitWidth-22,42,0);   
    }else if(inflg==2){
        // サイコロ結果処理
        randflg=0;
        recount=0;
        for(i=0;i<saikoro;i++){
            randresulttmp[i] = rand()%range;
            recount+=randresulttmp[i]+1;
        }
        randresult=recount;
        inflg++;
    }else if(inflg==3){
        for(i=0;i<saikoro;i++){
            PutSprite(diceimg[randresulttmp[i]], 416, 32+32*i, 
            &diceinfo[randresulttmp[i]],1);
        }       
        // Eをおしてください.
        sprintf(fname,"xewooositekudasaiimr");
        drawText(fname,11,225,InitWidth-22,42,0);
    }else if(inflg==4){
        inflg=0;
        turnstatus=5;
    }
}
        \end{lstlisting}

        rollDice関数の処理について説明する. inflg=0のとき,ダミー乱数を生成するための変数の初期化およびコールバック関数の登録を行っている.
        この処理は目的地設定のときの乱数生成の準備の処理とほぼ同じである.乱数の生成範囲は定数DICEMAX=6を与えている. inflg=1のときは図\ref{rolldice1}および
        図\ref{rolldice2}に示すようにダミー乱数で生成した値をサイコロで表示する処理と,「Eでサイコロをとめます.」というダイアログの表示を行っている.
        図\ref{rolldice1}はサイコロ1つ,つまりターンのスタート時に「サイコロ」を選択した場合,図\ref{rolldice2}は新幹線カードを使用してサイコロを4つにしたときの
        処理である.急行カード,特急カードの場合については,サイコロの数が変化するだけであるから省略する.
        図\ref{rolldice1}ではサイコロとして「5」が表示されいるが実際には100msおきにランダムなサイコロの画像が表示される.
        サイコロの画像データはdiceimg配列およびdiceinfo配列に格納されているおり,表示したいサイコロの目から1を引いた値をインデックスで指定することで
        サイコロの画像が表示できる.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{stopdice.eps}
            \caption{サイコロを振ったときの画面表示1}
             \label{rolldice1}
            \end{figure}   

            \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{saikoro4.eps}
            \caption{サイコロを振ったときの画面表示2}
             \label{rolldice2}
            \end{figure}   

        inflg=1の状態でキーボードからEキーの入力があるとinflgがインクリメントされ,inflg=2の処理が行われる.リスト\ref{rollDice}では24行目から33行目である.
        inflg=2の処理はダミーの乱数生成を停止して,本当の結果を計算することである.28行目から32行目でサイコロの数saikoroを
        ループ回数として,本当の結果を計算している.29行目で生成した乱数をグローバル変数(配列)randresulttmpに格納する. 
        格納した値はサイコロを画面に表示するためのインデックスの番号であるから,これに1を足してグローバル変数recoutに加算する.
        これによって,サイコロの結果の合計が変数recountに代入される. 最後に画面に結果を出力するための変数randresultにrecountを代入して,
        inflgをインクリメントしている. \\
        inflg=3およびinflg=4のときの処理について説明する. inflg=2でサイコロの出目の計算を行ったから,inflg=3ではこれを画面に表示する処理を行う.
        inflg=3では,図\ref{dicestop1}および図\ref{dicestop4}に示すように,サイコロの出目と「Eをおしてください.」というダイアログを表示する処理を行っている.
        inflg=3の処理は,リスト\ref{rollDice}の34行目から41行目である.サイコロの出目はrandresulttmp配列に格納されているため,これをPutSprite関数で表示している.
        inflg=3の状態でEキーを押すとinflgがインクリメントされ,inflg=4の処理が行われる.inflg=4の処理はturnstatus=5,つまり移動処理を行うようにturnstatusを更新する処理を行っている.
        これによって,サイコロの出目を表示する画面から,移動を行う画面に切り替わる.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{saikoro1r.eps}
            \caption{サイコロをとめたときの画面表示1}
             \label{dicestop1}
            \end{figure}   

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{saikoro4r.eps}
            \caption{サイコロをとめたときの画面表示2}
             \label{dicestop4}
            \end{figure}   

    \subsection{マス移動および停車駅の判定処理}
    マスの移動および停車駅の判定の処理について説明する. Display関数(リスト\ref{Display})ではturnstatus=5および6のときの処理である.
    まず,マス移動の処理であるturnstatus=5の処理について説明する. turnstaus=5の状態ではサイコロの出目の数だけ駅を移動することができる.
    「マス」と「駅」の違いについて説明する.「マス」は線路を含む移動できる部分のことである.これに対して「駅」は停車できる部分のことである. 
    例として,サイコロの出目で2が出たときの動作を説明する.図\ref{kekka2}がサイコロを振って2がでた状態である.図\ref{kekka2}から読み取れるように,
    移動可能なときは,右上のダイアログに残り移動可能な駅の数と目的地設定が表示される.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{kekka2.eps}
        \caption{出目が2の状態}
         \label{kekka2}
        \end{figure} 

    移動は次に示すキーで可能である. 図\ref{kekkamigi}に,図\ref{kekka2}の状態でDキーを押して右に1駅移動したときの画面表示を示す.
    図\ref{kekkamigi}から,右上のダイアログの残り移動可能な駅の数が2から1に減少したことが読み取れる.このように,移動に対応して
    右上のダイアログの値が変化する.ちなみに,図\ref{kekkamigi}の状態でAキーを押して戻ったときは図\ref{kekka2}に示す状態になる.
    ここでは1駅しか戻っていないが,2駅以上戻った場合も同様に残り移動可能な駅の数が上昇する.図\ref{kekkamigi}の状態で左以外の方向に
    移動すると,残り移動可能な駅の数が0になる.残り移動可能な駅の数が0になると,turnstatus=5からturnstatus=6の状態になり,どの駅に停車したのか
    判定され,処理が分岐する. 停車した駅ごとの処理は次節以降で述べる.

    \begin{itemize}
        \item 「W」 $\dots$ 上
        \item 「A」 $\dots$ 左
        \item 「S」 $\dots$ 下
        \item 「D」 $\dots$ 右
    \end{itemize}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{kekkamigi.eps}
        \caption{右に1駅移動した状態}
         \label{kekkamigi}
        \end{figure} 

    これらの動作の実装部分について説明する. まず,画面にダイアログを表示する処理について説明する. Display関数(リスト\ref{Display})ではturnstatus=5のときmoveMass関数を
    呼び出している.リスト\ref{moveMass}にmoveMass関数のコードを示す. moveMass関数の処理は図\ref{kekka2}の
    右上に表示されるダイアログを生成する処理である.ダイアログの生成は,11行目および12行目で行っている.
    13行目から16行目では,変数recountが0になったときにturnstatusを6つまり駅の判定に更新する処理を行っている.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=moveMass,caption=moveMass関数]
// 駅移動処理
void moveMass(void){
    char fname[150];
    drawMap();
    drawPlayer();  
    // あと
    // 　　hoge
    // 　　　マス
    // もくてきち
    // huga
    sprintf(fname,"aatoxxss%dxxssssllmasullxxmokutekitixx%s",recount,distination.name);
    drawText(fname,340,40,125,94,0);  
    if(recount==0){ // 移動マスを消費したらstatus更新
        turnstatus=6;
    }
}
        \end{lstlisting}

    次に移動の処理を行う部分について説明する. まず,キー入力を管理するkeyboard関数の処理について説明する.
    リスト\ref{keyboard5}にturnstatus=5のときの,keyboard関数のコードを示す.リスト\ref{keyboard5}において,
    キー入力から,進む方向を制御しているのは11行目から21行目である.進む方向はグローバル変数directionに格納している.
    変数directionと値の対応は上が0,右が1,下が2,左が3,どの方向でもないとき-623という仕様にしている.

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=keyboard5,caption=移動のための入力処理]
// キーボード入力管理
void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
if(keyboardflg==0){ // キーボード入力がロックされていないとき

    (省略)

    }else if(turnstatus==5){ //移動
        if(key=='w'){ // 上
            direction=0;
        }else if(key=='d'){ // 右
            direction=1;
        }else if(key=='s'){ // 下
            direction=2;
        }else if(key=='a'){ // 左
            direction=3;
        }else { // それ以外
            direction=-623;
        }
        if(direction!=-623){
            if(isMovable(transx,transy)){
                // 移動履歴を書き込み
                massRecord[randresult-recount][0]=transx;
                massRecord[randresult-recount][1]=transy;
                // 次の駅を計算
                nextStation(transx,transy);
                keyboardflg=1; // キーボード入力ロック
                glutTimerFunc(MOVETIME, MoveTimer, 0); //移動タイマー起動
            }
        }   
    } 
    
    (省略)

    if(turnstatus!=5){
        keyboardflg=1; // キーボード入力ロック
        glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
    }
}
}
                \end{lstlisting}

    キー入力から方向の情報を取得できたから,その方向に移動可能かどうかの判定を行う.この判定はリスト\ref{keyboard5}の
    23行目のisMovable関数で行っている.リスト\ref{isMovable}にisMovable関数のコードを示す. isMovable関数は引数として
    受け取ったMap配列のインデックス(x,y)とグローバル変数directionの値からその方向に移動できるかどうかを判定する関数である.
    探索は,探索したい方向のMap配列におけるインデックスをisWall関数に渡すことで行っている.　isWall関数の真偽によって,進める場合は1,進めない場合は0を返す. リスト\ref{isWall}に
    isWall関数のコードを示す. 進むことができるかどうかは,その方向が背景でないことを確認すればよい.このため, isWall関数は引数として受けとった
    Map配列におけるインデックスをgetmapnum関数(リスト\ref{getmapnum})に渡すことで,進みたい方向が背景かどうかを判別している. 
    進みたい方向が背景のときは1,背景でないときは0を返している.

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=isMovable,caption=isMovable関数]
// 0 : 上
// 1 : 右
// 2 : 下
// 3 : 左 
//
// 進めるとき 1
// 進めないとき 0
int isMovable(int x,int y){
    if(direction==0){ // 上
        if(isWall(x,y-1)){
            return 0;
        }
    }else if(direction==1){ //右
        if(isWall(x+1,y)){
            return 0;
        }    
    }else if(direction==2){ //下
        if(isWall(x,y+1)){
            return 0;
        }   
    }else{ //左
        if(isWall(x-1,y)){
            return 0;
        }   
    }
    return 1;
}
    \end{lstlisting}    

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=isWall,caption=isWall関数]
// 行先が壁かどうか判定
// 1 : 壁
// 0 : 壁でない
int isWall(int x,int y){
    if(getmapnum(x,y)==WALL){
        return 1;
    }
    return 0;
}
    \end{lstlisting}  
    
    移動可能かどうかの判定の結果,移動可能であれば次の停車駅の計算と移動履歴の書き込み処理を行う.移動履歴の書き込みは
    リスト\ref{keyboard5}の25行目および26行目で行っている.移動履歴の書き込みはグローバル変数(配列)massRecordに,
    今いる座標を書き込むことで行っている. 書き込まれるインデックスは1回目の移動のとき0,2回目の移動のとき1,$\dots$というふうになっている.
    28行目では,次の停車駅を計算する関数であるnextStation関数を実行している.リスト\ref{nextStation}にnextStation関数のコードを示す.
    nextStation関数では,変数directionの示す方向を,1マスずつgetmapnum関数を用いて探索することで,次に止まる駅の座標を計算している.
    なぜこのような関数が必要かというと,社長が移動する場所には線路と駅の2つがあり,停車できるのは駅だけである.
    次に停車する駅の座標を決めてから移動する処理を行わないと,移動のたびに駅か線路かを判定する必要があるため処理が重くなってしまう.
    このため先に停車する座標を計算してから移動の処理を行うようにしている. 次の停車駅の座標はグローバル変数nx,nyに代入される.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=nextStation,caption=nextStation関数]
// 次の駅を取得
void nextStation(int x,int y){
    int sx=x;
    int sy=y;
    if(direction==0){ // 上
        while(1){
            sy--;
            if(getmapnum(sx,sy)!=SENRO1){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==1){ // 右
        while(1){
            sx++;
            if(getmapnum(sx,sy)!=SENRO2){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==2){ // 下
        while(1){
            sy++;
            if(getmapnum(sx,sy)!=SENRO1){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==3){ // 左
        while(1){
            sx--;
            if(getmapnum(sx,sy)!=SENRO2){ // 駅を発見したら
                break;
            }
        }
    }else{ // エラーチェック用
        sx=-623;
        sy=-623;
    }
    // 次の駅の座標をセット
    nx=sx;
    ny=sy;
}
    \end{lstlisting}  

    次の停車駅の計算と移動履歴の書き込み処理が行えたから,移動の処理を行う.リスト\ref{keyboard5}では30行目の処理である.
    turnstatus=5以外のときは,キーボード入力があると一定時間入力を受け付けない処理を行っていたが, turnstatus=5のときは
    移動が完了するまでキーボードの入力をロックする仕様になっている.このため,リスト\ref{keyboard5}の37行目に示すように,
    turnstatus=5のときは例外処理としてkeyboardTimer関数を実行しないようになっている. \\
    　30行目でコールバック関数に登録している
    MoveTimer関数が,定数MOVETIME(100ms)おきに移動処理を行う関数である.リスト\ref{MoveTimer}にMoveTimer関数のコードを示す.
    リスト\ref{MoveTimer}において,移動の処理を行っているのは7行目のmove関数である.リスト\ref{move}にmove関数の処理を示す.
    move関数の処理はターン中の社長の座標を,移動する方向に定数MOVESIZE(ここでは16に設定している)だけ変化させる処理である.\\
    　リスト\ref{MoveTimer}の11行目から15行目は,nextStation関数で計算した次の駅の座標と,
    ターン中の社長の座標が一致しない,つまり停車する駅についていないときに,タイマーを再度呼び出す処理行っている.
    この処理によってnextStation関数で計算した駅の座標に一致するまで移動し続け,座標が一致すると移動が終了する.
    nextStation関数で計算した駅に到着したときの処理はリスト\ref{MoveTimer}の17行目から32行目である.
    17行目から32行目の処理は残り移動可能な駅の数の再計算である.この計算は,まず完了した移動と移動履歴を照合して
    進む,戻るのどちらの移動が行われたのか判別する. i回目に戻る移動が行われた場合,
    移動履歴を管理している配列massRecordのi-2番目に格納されている座標と,いまいる座標が一致するはずである.19行目および20行目ではこれを
    判定している. 座標が一致している場合は,変数recountをインクリメントすることで,残り移動可能な駅の数を増やしている.一致しない場合は
    進む移動が行われているから変数recountをデクリメントすることで,残り移動可能な駅の数を減らしている.\\
    　残り移動可能な駅の数が0のときの処理は28行目から32行目で行っている.残り移動可能な駅の数が0のとき,
    キーボードの入力をロックしている. 0でないときは,次の移動の入力を受け付けるために,キーボード入力のロックを解除している.
    これらの処理によって,駅の移動処理を実装している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=MoveTimer,caption=MoveTimer関数]
// 駅移動管理タイマー
void MoveTimer(int t)
{
    int transx;
    int transy;
    // 移動処理
    move();
    // 座標変換
    transx = players[turn].x/IMGSIZE;
    transy = players[turn].y/IMGSIZE;
    if((transx != nx)||(transy != ny)){ // 次の駅の座標と同じか
        glutTimerFunc(MOVETIME, MoveTimer, 0); // 同じでないときタイマー継続
    }else if((players[turn].x%IMGSIZE!=0)||(players[turn].y%IMGSIZE!=0)){  
        // 余りが0でないとき
        glutTimerFunc(MOVETIME, MoveTimer, 0); // タイマー継続
    }else{
        if(randresult-recount>0){ // まだ移動可能かどうか
        // 移動可能のとき,以前の移動履歴をチェック
            if((massRecord[randresult-recount-1][0]==transx)&&
            (massRecord[randresult-recount-1][1]==transy)){
                recount++; // 戻ったとき残りカウント数増加
            }else{
                recount--; // 進んだとき残りカウント数減少
            }
        }else{
            recount--; // カウント減少
        }
        if(recount==0){ // カウント終了のときキーボード入力をロック
            keyboardflg=1;
        }else{ // キーボード入力のロックを解除
            keyboardflg=0;
        }
    }
}
    \end{lstlisting}  

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=move,caption=move関数]
// 移動処理
void move(void){
    if(direction==0){ // 上
        players[turn].y-=MOVESIZE;
    }
    if(direction==1){ // 右
        players[turn].x+=MOVESIZE;
    }
    if(direction==2){ // 下
        players[turn].y+=MOVESIZE;
    }
    if(direction==3){ // 左
        players[turn].x-=MOVESIZE;
    }
}
    \end{lstlisting} 

    次にturnstatus=6のときの処理について説明する. turnstatus=6のときの処理は停車した駅を判定して処理を分岐する処理である.
    Display関数(リスト\ref{Display})ではturnstatus=6のとき, checkMass関数を実行している.リスト\ref{checkMass}にcheckMass関数のコードを示す.
    リスト\ref{checkMass}ではinflg=0のとき,社長が停車した駅の種類をgetmapnum関数で取得し,次に行う処理のためにinflgおよびturnstatusを
    更新する処理を行っている. 12行目に示すようにgetmapnum関数の返り値はローカル変数stに代入している.13行目から27行目では,
    この値を駅を表す定数と比較することで,駅ごとに処理を分けている.物件駅に停車したときの処理は13行目から20行目である.
    物件駅に停車したときは,まずその駅が目的駅かどうかを判定している.目的地のときは,変数goalflgを1にして,ターン中の社長の所持金を
    プラス3億円する処理を行っている.そして,inflgをインクリメントしている.inflg=1のとき図\ref{goal}に示すように,画面に「(社長名)しゃちょうが
    1ばんのり,おめでとうございます.(社長名)しゃちょうにプラス3億円.」と表示される. 図\ref{goal}の状態でEキーを押すと
    inflgインクリメントされ,inflg=2の処理が行われる. inflg=2の処理はturnstatusを1に更新する処理である. turnstatus=1の処理は
    目的地の設定を行う処理である.これによって目的地に到着したときに目的地が再設定される.\\
    　停車した駅がプラス駅,マイナス駅,カード駅のときのturnstatusの更新はリスト\ref{checkMass}の21行目から27行目で行っている.
    これらの処理によって,停車した駅を判定して,処理を分岐させている.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=checkMass,caption=checkMass関数]   
// 停車駅の判定と処理の分岐
void checkMass(void){
    int st; //止まった駅の番号を保持
    int transx,transy; // プレイヤーの座標変換用
    char fname[200];
    drawMap();
    drawPlayer();  
    if(inflg==0){
        keyboardflg=0; // キーボードロック解除
        transx = players[turn].x/IMGSIZE;
        transy = players[turn].y/IMGSIZE;
        st = getmapnum(transx,transy);
        if(st==PROPERTYMASU){ // 物件に止まったとき
            if((transx == distination.x)&&(transy == distination.y)){ // 目的地なら
                goalflg=1; // ゴールフラグをたてる
                players[turn].money+=30000; // プラス3億円
                inflg++;
            }else{ //目的地でないなら
                turnstatus=7;
            }
        }else if(st==PLUSMASU){ // プラス駅に止まったとき
            turnstatus=8;
        }else if(st==MINUSMASU){ // マイナス駅に止まったとき
            turnstatus=9;
        }else if(st==CARDMASU){ // マイナス駅に止まったとき
            turnstatus=10;
        }
    }else if(inflg==1){
        // hogeしゃちょうがhugaに1ばんのり.おめでとうございます.
        // hogeしゃちょうにプラス3億円.
        sprintf(fname,"%ssilatilouuga%sni1bannnorimroomedetouugozaiimasumr%s
        silatilouunillpurasull3oxexmr",players[turn].name,distination.name,
        players[turn].name);
        drawText(fname,11,225,InitWidth-22,42,0);              
    }else if(inflg==2){
        inflg=0;
        turnstatus=1; // 目的地再設定
    }
} 
    \end{lstlisting} 

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{goal.eps}
        \caption{目的地に到着したときの表示}
         \label{goal}
        \end{figure} 

    \subsection{物件駅の処理}
    物件駅に停車したときの処理について説明する. まず,物件駅に停車したときの動作について説明する.
    物件駅に停車すると図\ref{purbutu}に示すように物件情報,セレクトポジション,「Q しゅうりょう E こうにゅう」という
    ダイアログの3つが表示される. 図\ref{purbutu}では「W」キーおよび「S」キーで購入する物件を選択することができ,所持金が足りる場合は
    「E」キーを押すことで物件を購入することができる.また「Q」キーを押すことで物件の購入を終了できる.図\ref{ringo}に「りんごえん」を購入した時の画面表示を示す.図\ref{ringo}から
    「りんごえん」を購入すると,所持金が購入した物件の価格分引かれることがわかる.またレポートでは伝わらないが購入した物件は背景がプレイヤーカラーで
    表示される.また,誰かが購入した物件および所持金では購入できない物件は赤文字で表示される.レポートでは文字色の変化は伝わらないため
    画像は省略する.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{purbutu.eps}
        \caption{物件購入画面(長野駅)}
         \label{purbutu}
        \end{figure} 

        \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{ringo.eps}
        \caption{「りんごえん」を購入した場合の画面表示}
         \label{ringo}
        \end{figure} 

    物件を独占したときの画面表示について確認する.図\ref{dokusen}に長野駅を独占したときの画面表示を占めす.図\ref{dokusen}から読み取れるように,
    独占を行うと「(社長名)しゃちょうのどくせんです.」というダイアログが表示される.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{ringo.eps}
        \caption{独占したときの画面表示}
         \label{dokusen}
        \end{figure} 

    これらを実装しているコードについて説明する. 物件の購入はturnstatus=7の処理である.
    Display関数(リスト\ref{Display})ではturnstatus=7のとき, purchaseProperty関数を実行している.リスト\ref{purchaseProperty}にpurchaseProperty関数の
    コードを示す.また,リスト\ref{keyboard7}にturnstatus=7のときのkeyboard関数のコードを示す.\\

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=purchaseProperty,caption=purchaseProperty関数]
// 物件購入処理
void purchaseProperty(void){
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        keyboardflg=0;
        selectpos=0;
        inflg++;
    }else if(inflg==1){
        drawStation(); // 物件情報描画
    }else if(inflg==2){
        inflg=0;
        turnstatus=15;
    }
}
    \end{lstlisting} 

    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=keyboard7,caption=物件購入時のキーボード入力の処理]
// キーボード入力管理
void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
if(keyboardflg==0){ // キーボード入力がロックされていないとき
    
    (省略)

    }else if(turnstatus==7){ // 物件購入
        locktime=200;
        if(key=='s'){ // ポジションを下へ
            if(selectpos<propertynum-1){
                selectpos+=1;
            }            
        }else if(key=='w'){ // ポジションを上へ
            if(selectpos>=1){
                selectpos-=1;
            }            
        }else if(isE(key)){ //　物件購入
            if(ispurchase(selectpos)){
                purchase(selectpos);
            }
        }else if(key=='q'){ // 購入終了
                inflg++;
        }
        }

        (省略)

        if(turnstatus!=5){
            keyboardflg=1; // キーボード入力ロック
            glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
        }
}
}
    \end{lstlisting} 

    purchaseProperty関数では, inflg=1のときセレクトポジションを管理する変数selectposを0に設定している.これによって,物件購入
    画面が表示されたときにセレクトポジションが最上部の物件を選択するようになっている. inflg=2のときは, drawStation関数を実行して
    物件の情報およびダイアログを表示している.リスト\ref{drawStation}にdrawStation関数のコードを示す.
    drawStation関数では,まず停車した駅の座標から,どの物件駅に停車したのかを判別している.この処理はリスト\ref{drawStation}の
    10行目から18行目で行っている.駅の判別が行えたから,画面に物件の情報を描画する処理を行う. 21行目から24行目で駅名,27行目から31行目で
    所持金の描画を行っている. 物件の表示は34行目から64行目で行っている.所持している物件をプレイヤーカラーの背景で描画しているのは43行目から
    47行目の処理である.セレクトポジションを描画しているのは50行目から53行目での処理である. ターンスタート時の処理と同様にkeyboard関数(リスト\ref{keyboard7})の
    12行目から19行目でキー入力に合わせて変数selectposを更新し,50行目から53行目で変数selectopsを描画する処理を行うことでセレクトポジションを表示している.\\
    
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=drawStation,caption=drawStation関数]
 // 物件情報を描画
void drawStation(void){
    char fname[100];
    int i,j;
    int holder;
    int color;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
    // どの駅か識別
    for(i=0;i<STATIONNUM;i++){
        // 駅の座標が一致したら
         if((stations[i].x==transx)&&(stations[i].y==transy)){
            // 物件数を取得
            propertynum = stations[i].propertynum; 
            // 配列番号を取得
            stid = i;
         }
     }
    
    // 駅名表示
    glColor3ub(255,245,238);
    drawDialog(11,11,InitWidth-22,42);
    sprintf(fname,"%seeki",stations[stid].name);
    drawString(fname,0,16,16,1);
    
    // 所持金表示
    glColor3ub(playercolor[turn][0],playercolor[turn][1],
    playercolor[turn][2]);
    drawDialog(11,61,InitWidth-22,34);
    drawString("silozikinn",0,16,61+8,0.5);
    drawMoney(players[turn].money,2*InitWidth/4,61+8,0,0.5);
    
    // 物件表示
    glColor3ub(255,245,238);
    drawDialog(11,103,InitWidth-22,11+17*stations[stid].propertynum);
    for(j=0;j<propertynum;j++){
        
        // 収益率を文字列に変換
        sprintf(fname,"%dpx",stations[stid].plist[j].earnings);
        
        // 物件の所有者がいるとき,所有者カラーで物件を囲む
        holder = stations[stid].plist[j].holder;
        if(holder!=0){
            glColor3ub(playercolor[holder-1][0],playercolor[holder-1][1],
            playercolor[holder-1][2]);
            drawQUAD(16,108+j*17,InitWidth-32,17);
        }

        // セレクトポジションを表示
        if(selectpos == j){
            glColor3ub(255,0,0);
            drawQUAD(16,108+j*17,InitWidth-32,17);                 
        }
        // 物件の表示色設定
        if(ispurchase(j)){
            color=0;
        }else{
            color=1;
        }
        // 物件を表示
        drawString(stations[stid].plist[j].name,color,18,42+11+50+7+17*j,0.5);
        drawMoney(stations[stid].plist[j].price,InitWidth/2-16,42+11+50+7+17*j,color,0.5);
        drawString(fname,color,16+3*InitWidth/4,42+11+50+7+17*j,0.5);
    }
    // 独占ダイアログ表示
    if(stations[stid].ismonopoly!=0){
        sprintf(fname,"%ssilatilouunodokusenndesumr",
        players[stations[stid].ismonopoly-1].name);
        drawText(fname,11,223,InitWidth-22,32,0);
        sprintf(fname,"xqsssiluuurilouuxxxesskouuniluuu");
        drawText(fname,11,273,InitWidth-22,42,0);
    }else{ // 操作ダイアログ表示
            sprintf(fname,"xqsssiluuurilouuxxxesskouuniluuu");
            drawText(fname,11,225,InitWidth-22,42,0);
    }
}       
    \end{lstlisting} 

    物件が購入できるとき黒字,購入できないとき赤字で表示する処理はリスト\ref{drawStation}の55行目から59行目で行っている. 55行目ではispurchase関数という
    関数を用いて物件が購入できるかどうかを判定している.リスト\ref{ispurchase}にispurchase関数のコードを示す. ispurchase関数では
    物件が購入できるかどうかを,既に誰かが購入しているケースと値段が足りないケースの2つに分けて判定している.
    既に誰かの物件かどうかはplayerstatus構造体のholderメンバに記述されているからこれを確認している.値段が足りるかどうかは,ターン中の社長の
    所持金moneyと購入しようとしている物件の値段を比較することで行っている.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=ispurchase,caption=ispurchase関数]
// 物件が購入できるか取得
// 1 : 取得可能
// 0 : 取得不可能
int ispurchase(int id){
    int flg=1;
    // 既に誰かの物件のとき
    if(stations[stid].plist[id].holder!=0){
        flg=0;
    }
    // 値段が足りないとき
    if(players[turn].money < stations[stid].plist[id].price){ 
        flg=0;
    }
    return flg;
}
    \end{lstlisting} 

    独占ダイアログおよび画面下部の表示はリスト\ref{drawStation}の66行目から75行目の処理で行っている.独占かどうかはstations構造体の
    メンバismonopolyに記述されているから,これを判定して独占ダイアログを表示/非表示にする処理を行っている.\\
    　次に購入の処理について説明する.購入はEキーが押されたときに行われる.リスト\ref{keyboard7}の20行目から23行目がEキーを押された
    ときの処理である. Eキーが押されたとき,購入可能かどうかをispurchase関数で確認して,購入可能であれば購入処理を行うpurchase関数を
    実行している.リスト\ref{purchase}にpurchase関数のコードを示す. purchase関数の6行目から10行目では,総資産,所持金,購入フラグ
    の3つを更新している. 12行目から21行目では,独占したかどうかのチェックを行っている.独占したかどうかは,
    同一駅内の全ての物件の購入フラグがターン中の社長のものと一致するかどうかを確認すれば判定できる.このため,for文を用いて
    物件の購入フラグをチェックしている.独占のときは独占フラグを立てる処理を行っている.これらの処理によって物件を購入する処理を
    実装している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=purchase,caption=purchase関数]
//物件購入処理
void purchase(int id){
    int i;
    int monopolyCheck=0; // 独占チェック用
    // 総資産を計算
    players[turn].assets+=stations[stid].plist[selectpos].price;
    // 所持金を計算
    players[turn].money-=stations[stid].plist[selectpos].price;
    // 購入済みフラグをたてる
    stations[stid].plist[selectpos].holder=turn+1;    
    // 独占チェック
    for(i=0;i<propertynum;i++){
        if(stations[stid].plist[i].holder==turn+1){
            monopolyCheck++;
        }
    }    
    // 独占のとき
    if(monopolyCheck==propertynum){
        // 独占フラグをたてる
        stations[stid].ismonopoly=turn+1;
    }    
}
    \end{lstlisting} 
    
    物件購入画面でQキーを押してたときの処理について説明する.リスト\ref{keyboard7}の24行目から26行目に示すように, Qキーを押すと
    inflgがインクリメントされ,inflg=2の処理が行われる.リスト\ref{purchaseProperty}の13行目に示すように, inflg=2のときturnstatusを15,
    つまりターンの終了処理に更新している.これによって, Qキーを押すと物件購入処理が終了する.
    
    \subsection{プラス駅の処理}
    プラス駅に停車したときの処理について説明する.まず,プラス駅に停車したときの動作について説明する.
    図\ref{plusmass}にプラス駅に停車したときの画面表示を示す.図\ref{plusmass}では
    「2349万円」と表示されている部分は,実際には100msおきにランダムな金額が表示されている.図\ref{plusmass}の状態で
    Eキーを押すと図\ref{plusmassresult}のようにランダムな表示が停止して所持金が表示される.図\ref{plusmassresult}の
    状態でEキーを押すとターンが終了する.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{plusmass.eps}
        \caption{プラス駅に停車したときの画面表示}
         \label{plusmass}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{plusresult.eps}
        \caption{図\ref{plusmass}の状態でEキーを押したときの画面表示}
         \label{plusmassresult}
        \end{figure}

    この動作を実行しているのがturnstatus=8のときの処理である.
    Display関数(リスト\ref{Display})ではturnstatus=8のときplusMass関数を実行している.
    リスト\ref{plusMass}にplusMass関数のコードを示す. リスト\ref{plusMass}ではinflg=0のとき
    ダミータイマーを起動する処理を行っている. 乱数の生成範囲はpulsarrayに最小値,最大値という形で記述されている.例えば4月の場合
    2000万円から4000万円の範囲の乱数が生成される.範囲は月ごとに乱数生成に変えることで,季節ごとにもらえる金額が変化する仕様を実
    装している. inflg=1のときはダミーの乱数の生成結果を画面に出力する処理を行っている. inflg=1からinflg=2の状態への更新はEキーの
    入力によって行われる. turnstatus=8のときのキーボードの処理はEキーの入力でinflgをインクリメントするだけであるから省略する.
    inflg=2では本当の結果を計算する処理を行ってinflgをインクリメントする処理を行っている. inflg=3のときは本当の結果と所持金を表示する
    ダイアログを表示する処理を行っている.これによって図\ref{plusmassresult}に示す画面表示が行われている. inflg=3の状態で
    Eキーが押されるとinflg=4の処理が行われる. inflg=4のとき,turnstatusを15,つまりターンの終了処理を行うように更新している.
    これらの処理によってプラス駅の処理を実装している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=plusMass,caption=plusMass関数]
// プラス駅の色
int pluscolor[3] = {0,0,205};

// プラス駅の月別乱数表
int plusarray[MAXMONTH][2] = {{400,1200}, // 1月
                               {200,800}, // 2月
                               {400,1500}, // 3月
                               {2000,4000}, // 4月
                               {3000,7000}, // 5月
                               {4000,8000}, // 6月
                               {12000,30000}, // 7月
                               {35000,70000}, // 8月
                               {18000,32000}, // 9月
                               {6000,12000}, // 10月
                               {3000,7000}, // 11月
                               {2000,4000}}; // 12月

// プラス駅の処理
void plusMass(){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        dummynum=1;
        // ダミータイマー起動
        dummyresult[0]=0;
        keyboardflg=0;
        range=plusarray[month-1][1]-plusarray[month-1][0];
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg++;            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(pluscolor[0],pluscolor[1],pluscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(plusarray[month-1][0]+dummyresult[0],InitWidth/2-IMGSIZE*3,
        InitHeight/2-16,0,1);            
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = rand()%range;
        tmpmoney = plusarray[month-1][0]+randresult;
        players[turn].money+=tmpmoney;
        inflg++;
    }else if(inflg==3){
        // 所持金ダイアログ表示
        glColor3ub(pluscolor[0],pluscolor[1],pluscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(tmpmoney,InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);
        // 所持金表示
        glColor3ub(playercolor[turn][0],playercolor[turn][1],playercolor[turn][2]);
        drawDialog(11,220,InitWidth-22,42);
        drawMoney(players[turn].money,InitWidth/2,225,0,0.5);
        // しょじきん
        sprintf(fname,"silozikinn");
        drawString(fname,0,16,225,0.5);               
    }else if(inflg==4){
        inflg=0;
        turnstatus=15;
    }
}
    \end{lstlisting}

    \subsection{マイナス駅および借金の処理}
    マイナス駅および借金時の処理について説明する.まず,マイナス駅に停車したときの動作を確認する.
    図\ref{minusmass}にマイナス駅に停車したときの画面表示を示す.図\ref{minusmass}で「-1339万円」と表示されている部分は,
    実際には100msときにランダムな金額が表示されている.図\ref{minusmass}の状態でEキーを押すと図\ref{minusmassresult}のように
    ランダムな表示が停止して所持金が表示される. 所持金が負の値でない場合は,図\ref{minusmassresult}の状態でEキーを押すと
    ターンが終了する.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{minus.eps}
        \caption{マイナス駅に停車したときの画面表示}
         \label{minusmass}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{minusresult.eps}
        \caption{図\ref{minusmass}の状態でEキーを押したときの画面表示}
         \label{minusmassresult}
        \end{figure}

    次に,借金を背負ったときの動作について確認する.借金を背負ったときの動作は物件を持っているかどうかで
    変化する.まず,物件を一つも処理していないときの動作を確認する.なお,確認のためにマイナス駅で生成される乱数の値を
    プログラムで事前に打ち込んでいる.図\ref{minus20}に物件を一つも持っていないときにマイナス駅に
    停車して,-19億円の借金を負ったときの画面表示を示す.図\ref{minus20}の状態でEキーを押すと,図\ref{minus20result}に
    示すように「うれるぶっけんがありません.しゃっきんをせおってしまいました.」というダイアログが表示される.
    図\ref{minus20result}の状態でEキーを押すとターンが終了する.
    
    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{minus20.eps}
        \caption{-19億円の借金を背負った状態}
         \label{minus20}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{minus20result.eps}
        \caption{売れる物件がないというダイアログの表示}
         \label{minus20result}
        \end{figure}

    次に,物件を持っているときの動作を確認する.いま,ある社長が図\ref{obuse}に示すように
    小布施駅の物件を5つ購入し,所持金が4400万円である状態にあるとする.この社長の総資産は5600万円である.
    図\ref{obuse}で物件を購入した次のターンに,マイナス駅で所持金から20億円引かれるときの画面表示を図\ref{b5}に示す.
    図\ref{b5}から,「しゃっきんをせおってしまいました.5けんのぶっけんをばいきゃくします.」と表示されていることがわかる.
    この場合,総資産5600万円に対して借金額が19億4600万円であるから,すべての物件を売却して,かつ19億円の借金が所持金に残る.
    このため,小布施で購入した5件の物件がすべて売却されている. 図\ref{b5}の次のターンに所持金を確認すると図\ref{b6}に示すように
    -19億円になっている.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{obuse.eps}
        \caption{小布施の物件を購入した状態}
         \label{obuse}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{b5.eps}
        \caption{売却した物件数の表示}
         \label{b5}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{b6.eps}
        \caption{所持金が負になっていることの確認}
         \label{b6}
        \end{figure}

        借金をしたが,物件を売却することで借金が回復する場合についても確認する.先の例と同様に小布施の物件を5つ
        購入し,マイナス駅で600万円の借金をした状態であるとする.図\ref{b1}にこの状態で借金を返済する処理を行った
        ときの画面表示を示す.図\ref{b1}から「しゃっきんをせおってしまいました.1けんのぶっけんをばいきゃくします.」
        という表示が行われていることがわかる.実際に小布施駅に戻って売却された物件を確認すると,図\ref{hokusai}に示すように
        借金額600万円に最も近い600万円の北斎館が売却されていることがわかる.

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{b1.eps}
            \caption{借金を返済したときの画面表示}
             \label{b1}
            \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{hokusai.eps}
            \caption{物件が購入済みでなくなっていることの確認}
             \label{hokusai}
            \end{figure}

        これらを実装しているのがturnstatus=9のときの処理である. Display関数(リスト\ref{Display})ではturnstatus=9のとき
        minusMass関数を実行している.リスト\ref{minusMass}にminusMass関数のコードを示す. turnstatus=9のときの
        キーボードの処理はEキーの入力でinflgをインクリメントするだけであるから省略する.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=minusMass,caption=minusMass関数]
// マイナス駅の色
int minuscolor[3] = {220,20,60};

// マイナス駅の月別乱数表
int minusarray[MAXMONTH][2] = {{10000,25000}, // 1月
                               {20000,80000}, // 2月
                               {10000,25000}, // 3月
                               {500,1500}, // 4月
                               {400,1200}, // 5月
                               {300,1000}, // 6月
                               {200,600}, // 7月
                               {100,400}, // 8月
                               {500,1500}, // 9月
                               {2000,4000}, // 10月
                               {3000,8000}, // 11月
                               {4000,9000}}; // 12月

// マイナス駅の処理
void minusMass(void){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        // ダミータイマー起動
        dummynum=1;
        dummyresult[0]=0;
        keyboardflg=0;
        range=minusarray[month-1][1]-minusarray[month-1][0];
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg=1;            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(minuscolor[0],minuscolor[1],minuscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(-minusarray[month-1][0]-dummyresult[0],
        InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);            
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = rand()%range;
        tmpmoney = -minusarray[month-1][0]-randresult;
        players[turn].money+=tmpmoney;
        inflg++;
    }else if(inflg==3){
        // 所持金ダイアログ表示
        glColor3ub(minuscolor[0],minuscolor[1],minuscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(tmpmoney,InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);
        // 所持金表示
        glColor3ub(playercolor[turn][0],playercolor[turn][1],playercolor[turn][2]);
        drawDialog(11,220,InitWidth-22,42);
        drawMoney(players[turn].money,InitWidth/2,225,0,0.5);
        sprintf(fname,"silozikinn");
        drawString(fname,0,16,225,0.5);               
    }else if(inflg==4){
        if(players[turn].money<0){ //借金を背負ったとき
            inflg++;
        }else{ // それ以外
            inflg=0;
            turnstatus=15;
        }
    }else if(inflg==5){ // 借金返済処理
        rdebet = debtprocess(); // 売却した物件数を取得
        inflg++;
    }else if(inflg==6){
        if(rdebet==-1){
            // うれるぶっけんがありません．しゃっきんをせおってしまいました.
            sprintf(fname,"uurerubultkenngaaarimasennmr
            silaltkinnwoseoolttesimaiimasitamr");
        }else{
            // しゃっきんをせおってしまいました.hogeけんのぶっけんをばいきゃくしました.
            sprintf(fname,"silaltkinnwoseoolttesimaiimasitamr
            %dkennnobultkennwobaiikilakusimasitamr",rdebet);
        }
        drawText(fname,11,225,InitWidth-22,42,0); 
    }else if(inflg==7){
        inflg=0;
        turnstatus=15;
    }
}
        \end{lstlisting}

        inflg=1からinflg=4までの処理はプラス駅の場合とほぼ同じである.プラス駅との違いは,符号の扱いである.
        RandTimer関数は0以上の乱数しか生成できない.このためマイナス駅での月別の乱数の範囲は,minusarrayでマイナスされる額
        の絶対値を保持している.そして,生成した乱数を-1倍することでマイナスする額を計算している.\\
        　プラス駅の処理と異なるのはinflg=4以降の処理である. inflg=4のときターン中の社長の所持金を確認して,所持金が
        0未満,つまり借金を負ったときは,inflg=5の処理を行うようにしている. 借金を負っていないときはturnstatus=15,つまり
        ターン終了の処理を行うようにturnstatusを更新している.\\
        　inflg=5および6のとき,借金を返済する処理を行い,結果を画面に表示する処理を行っている.借金の返済処理は
        64行目のdebtprocess関数で行っている.リスト\ref{debtprocess}にdebtprocess関数のコードを示す. debtprocess関数は
        売却した物件の数を返り値として返す関数である.総資産が0円のときは,売却できる物件がないから-1を返す.
        総資産が0円かどうかの判定は6行目から8行目で行っている. 11行目から31行目では,借金額が総資産よりも大きいときに,
        ターン中の社長の物件を全ての売却する処理を行っている.物件の売却は購入フラグを0にして所持金,総資産を再計算
        することで行っている. 
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=debtprocess,caption=debtprocess関数]
// 物件売却処理
int debtprocess(void){
    int i,j;
    int count=0;
    // 資産がないとき
    if(players[turn].assets==0){
        return -1;
    }

    // 借金が資産より大きいとき,全ての物件を売却
    if(abs(players[turn].money)>=players[turn].assets){
        for(i=0;i<STATIONNUM;i++){
            // 独占解除
            if(stations[i].ismonopoly==turn+1){
                stations[i].ismonopoly=0;
            }
            for(j=0;j<stations[i].propertynum;j++){
            if(stations[i].plist[j].holder==turn+1){
                // 購入フラグ初期化
                stations[i].plist[j].holder=0;
                // 所持金を計算
                players[turn].money+=stations[i].plist[j].price;
                // 総資産を計算
                players[turn].assets-=stations[i].plist[j].price;
                // 売った物件数をカウント
                count++;
                }
            }
        }  
        return count;
    }

    // 借金が資産より小さいとき
    count +=sale(0,1);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(0,0);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(1,1);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(1,0);
    return count;
}
        \end{lstlisting}

        借金が総資産よりも小さいときに物件を売却する処理はリスト\ref{debtprocess}の34行目から47行目では行っている.
        売却する物件の優先順位は次のような仕様であった. 34行目から47行目ではsale関数を用いて優先順位の条件
        ごとに物件を売却する処理を行っている.
        \begin{enumerate}
            \item 独占している駅の物件でなく,借金額よりも価格が高い物件
            \item 独占している駅の物件でなく,借金額よりも価格が低い物件
            \item 独占している物件で,借金額よりも価格が高い物件
            \item 独占している物件で,借金額よりも価格が低い物件
        \end{enumerate}

        リスト\ref{sale}にsale関数のコードを示す. sale関数は引数として売却する物件の条件を受け取る.
        引数ismonopolyが1のとき独占の物件の場合も売却, 0のとき独占の物件は売却しないという条件をつけることができる.
        また,引数highは1のとき借金額より高い物件を売却, 0のとき借金額より低い物件を売却するという条件をつけることができる.
        どの物件を売却するか探索を行っているのは,リスト\ref{sale}の11行目から71行目である. 物件の探索は,まず引数で与えられた
        条件に合うかどうかを判定したあとに,借金額とその物件の価格の差を計算している.差がローカル変数nearestより小さいときは,
        その駅のインデックスをローカル変数nearestst,物件のインデックスをnearestidに保存する.また変数nearestの値を
        今計算した差の値に更新する.これを該当する物件について繰り返すことで,最も借金額に近い物件を見つけることができる.\\
        　探索によってどの物件を売却すればよいか分かったから物件を売却する処理を行う.この処理はリスト\ref{sale}の
        75行目から86行目で行っている. debtprocess関数では,売却する物件の優先順位にあうようにsale関数の引数を指定することで
        独占でない物件から売却する処理を実装している.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=sale,caption=sale関数]
// 物件を売却する関数
//ismonopoly : 独占の物件を売るか
// high : 借金より高い物件から売るか
int sale(int ismonopoly,int high){
    int i,j;
    int nearest=99999;
    int nearestst=-1;
    int nearestid=-1;
    int count=0;
while(1){
    for(i=0;i<STATIONNUM;i++){ // 全ての駅について
    if(ismonopoly){ // 独占の物件を売るとき
        for(j=0;j<stations[i].propertynum;j++){ // 全ての物件について
            if(stations[i].plist[j].holder==turn+1){ 
                // ターン中のプレイヤーの物件のとき
                // 物件の価格が借金の絶対値より大きいとき
                if(high){
                // 借金より高い物件かチェック
                if(stations[i].plist[j].price>=-players[turn].money){
                    // 値段が近いとき
                    if(abs(-players[turn].money-stations[i].plist[j].price)<nearest){
                        // 候補として更新
                        nearest = abs(-players[turn].money-stations[i].plist[j].price);
                        nearestst = i;
                        nearestid = j;                              
                    }
                }
                }else{
                    // 値段が近いとき
                    if(abs(-players[turn].money-stations[i].plist[j].price)<nearest){
                        // 候補として更新
                        nearest = abs(-players[turn].money-stations[i].plist[j].price);
                        nearestst = i;
                        nearestid = j;                              
                    }
                }
            }
        }
    }else{
        if(stations[i].ismonopoly!=turn+1){ // 独占でないとき
            for(j=0;j<stations[i].propertynum;j++){ // 全ての物件について
                if(stations[i].plist[j].holder==turn+1){ 
                    // ターン中のプレイヤーの物件のとき
                    // 物件の価格が借金の絶対値より大きいとき
                    if(high){
                    // 借金より高い物件かチェック
                    if(stations[i].plist[j].price>=-players[turn].money){
                        // 値段が近いとき
                        if(abs(-players[turn].money-stations[i].plist[j].price)<nearest){
                            // 候補として更新
                            nearest = abs(-players[turn].money-
                            stations[i].plist[j].price);
                            nearestst = i;
                            nearestid = j;                                 
                        }
                    }
                    }else{
                        // 値段が近いとき
                        if(abs(-players[turn].money-stations[i].plist[j].price)<nearest){
                            // 候補として更新
                            nearest = abs(-players[turn].money-
                            stations[i].plist[j].price);
                            nearestst = i;
                            nearestid = j;                                 
                        }
                    }
                }
            }
        }
        }
    }
    if(nearestst==-1){ // 売れる物件がない
        break;
    }else{
        count++; // 売った物件の数を追加
         // 購入フラグ解除
        stations[nearestst].plist[nearestid].holder=0;
        // 所持金を計算
        players[turn].money+=stations[nearestst].plist[nearestid].price;
        // 総資産を計算
        players[turn].assets-=stations[nearestst].plist[nearestid].price;
        // 借金が回復したとき
        if(players[turn].money>=0){
            return count;
        }
    }      
}
    return count;
}
        \end{lstlisting}

        inflg=6では,　inflg=5で行った借金返済処理の結果を画面に表示する処理を行っている.リスト\ref{minusMass}では
        66行目から76行目の処理である. debtprocess関数の返り値が-1,つまり売却できる物件がないときは図\ref{minus20result}
        で示した「うれるぶっけんがありません.しゃっきんをせおってしまいました.」というダイアログを表示している.
        debtprocess関数の返り値が-1以外の場合,図\ref{b5}や図\ref{b1}に示したように「しゃっきんをせおってしまいました.hoge
        けんのぶっけんをばいきゃくしました.」というダイアログを表示してしている.\\
        　inflg=6の状態でEキーを押すとinflg=7の処理が行われる. inflg=7の処理はturnstatus=15,つまりターン終了の処理が
        行われるようにturnstatusを更新する処理である.

    \subsection{カード駅の処理}
    カード駅に停車したときの処理について説明する.まず,カード駅に停車したときの動作について説明する.
    図\ref{randcard}にカード駅に停車したときの画面表示を示す.図\ref{randcard}で「しんかんせんカード」と
    表示されている部分は,実際には100msおきにランダムな金額が表示されている.図\ref{randcard}の状態でEキーを押すと,
    図\ref{randresult}に示すようにランダムな表示が停止し,手に入れたカードとダイアログが表示される.
    図\ref{randresult}の状態でEキーを押すとターンが終了する.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{randcard.eps}
        \caption{カード駅に停車したときの画面表示}
         \label{randcard}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{randresult.eps}
        \caption{図\ref{randcard}でEキーを押したときの画面表示}
         \label{randresult}
        \end{figure}

    カードは5枚まで持てる仕様になっている.このため,カードを5枚持った状態でカード駅に停車すると
    図\ref{motenai}に示すように「これいじょうカードをもてません.」というダイアログが表示され新しいカードを
    入手する処理は行われない.図\ref{motenai}の状態でEキーを押すとターンが終了する.


    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{motenai.eps}
        \caption{カードを5枚持っているときにカード駅に停車した状態}
         \label{motenai}
        \end{figure}

        これらの処理を実装しているのは,turnstatus=10のときの処理である.Display関数(リスト\ref{Display})では
        turnstatus=10のときcardMass関数を実行している.リスト\ref{cardMass}にcardMass関数のコードを示す.
        カード駅の動作から分かるように,cardMass関数の処理は, plusMass関数とほぼ同じである. このためinflg=0～inflg=4の
        処理の説明は省略する.カード枚数が5枚のときの処理について説明する.カード枚数の判定は18行目および19行目で行っている.
        カードが5枚の時はinflg=5の処理を行うようにinflgを更新している. inflg=5のときの処理は53行目から
        56行目に記述されている. inflg=5のとき，図\ref{motenai}に示したように「これいじょうカードをもてません.」
        と画面に表示する処理を行っている.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=cardMass,caption=cardMass関数]
// カード駅の色
int cardcolor[3] = {255,255,33};
char cardname[CARDNUM][50]={"kiluuukouullkallmslldoll",
                         "toltkiluuullkallmslldoll",
                         "sinnkannsennllkallmslldoll",
                         "llsamilttokallmslldoll",
                         "bulttobillkallmslldoll",
                         "10oxexllkallmslldoll",
                         "tokuseiireiillkallmslldoll",
                         "gouusoltkiluuullkallmslldoll"};

// カード駅の処理
void cardMass(void){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        if(players[turn].cardnum==CARDMAX){
            inflg=5;
        }else{
            dummynum=1;
            // ダミータイマー起動
            dummyresult[0]=0;
            keyboardflg=0;
            range=CARDNUM;
            randflg=1;
            glutTimerFunc(RANDTIME, RandTimer, 0);
            inflg=1;
        }            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(cardcolor[0],cardcolor[1],cardcolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawString(cardname[1+dummyresult[0]],0,InitWidth/2-IMGSIZE*4,InitHeight/2-16,1);           
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = 1 + rand()%range;
        players[turn].card[players[turn].cardnum]=randresult;
        players[turn].cardnum++;
        inflg++;
    }else if(inflg==3){
        // 入手したカードを表示
        glColor3ub(cardcolor[0],cardcolor[1],cardcolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawString(cardname[randresult-1],0,InitWidth/2-IMGSIZE*4,InitHeight/2-16,1); 
        // hogeをてにいれました.
        sprintf(fname,"%swoteniiiremasitamr",cardname[randresult-1]);
        drawText(fname,11,225,InitWidth-22,42,0);                     
    }else if(inflg==4){
        inflg=0;
        turnstatus=15;
    }else if(inflg==5){
        // これいじょうカードをもてません.
        sprintf(fname,"koreiizilouullkallmslldollwomotemasennmr");
        drawText(fname,11,225,InitWidth-22,42,0);            
    }else if(inflg==6){
        inflg=4;
    }
};
        \end{lstlisting}

    \subsection{ターン終了時の処理}
    ターン終了時の処理について説明する. この処理はturnstatus=15のときの処理である. Display関数(リスト\ref{Display})では
    turnstatus=15のときendTurn関数を実行している.リスト\ref{endTurn}にendTurn関数のコードを示す.
    endTurn関数では,ターン,月,季節の3つを更新する処理行っている. 9行目から15行目では,ターンおよび月の更新結果から
    決算または最終成績の処理を行うかどうかを判定している. 3月の3人のターンが終了した場合はturnstatus=16,つまり決算の処理
    を行うようにturnstatusを更新している. 決算の条件に加えて3年目のときは,turnstatus=17,つまり最終成績を表示する処理を行うように
    turnstatusを更新している. 決算,最終成績のどちらの処理も行われない場合はturnstatus=2,つまりターンのはじめの処理を行うように
    turnstatusを更新している.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=endTurn,caption=endTurn関数]
// ターン終了処理
void endTurn(void){
// ターン終了処理
    turn++;
    if(turn==3){
        month++;
    }
    // 決算月かどうか判別
    if((turn==3)&&(month==4)){
        if(year==3){
            turnstatus=17; // 最終成績
        }else{
            turn=0;
            turnstatus=16;  // 決算
        }
    }else{
        if(turn==3){ // ターン初期化
            turn=0;
        }
        if(month==MAXMONTH+1){
            month=1; // 12月まできたら1月にリセット
        }
        calseason(); // 季節再計算
        turnstatus=2; // ターンのはじめにもどる
    }
}
    \end{lstlisting}

    \subsection{決算および最終成績の処理}
    決算および最終成績の処理について説明する.決算と最終成績の違いは,画面に表示する文字と最後に表示されるゲーム終了画面であるから
    ここでは決算について説明する. まず,実際の動作について確認する. いま,プレイヤー1社長が図\ref{obuse}に示したように
    小布施の物件を5つ所持しており,所持金が「4400万円」であるとする.
    決算は毎年3月が終了すると行われる.決算が始まるとまず,図\ref{hujisan}に示す画面が表示される.図\ref{hujisan}の状態で
    Eキーを押すと,図\ref{shueki}に示すように収益額が表示される. 4月が始まると3月の所持金に図\ref{shueki}で表示されている
    収益額が加算された状態になる.図\ref{yorozu}に,決算後の4月のプレイヤー1社長の所持金を示す.図\ref{yorozu}から読み取れるように
    プレイヤー1社長の所持金が,3月の所持金4400万円に収益額3600万円を加えた8000万円になっていることが読み取れる.

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.8]{sp1.png}
        \caption{決算開始時の画面表示}
         \label{hujisan}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{shueki.eps}
        \caption{収益額の画面表示}
         \label{shueki}
        \end{figure}

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{yorozu.eps}
        \caption{収益額が加算されていることの確認}
         \label{yorozu}
        \end{figure}

        図\ref{shueki}の状態でEキーを押すと,図\ref{sisan}に示すように総資産と所持金の和が表示される.
        このためプレイヤー1社長の場合,所持金4400万円,資産5600万円,収益額3600万円を足した
        1億3600万円が画面に表示されている.決算の場合は,図\ref{sisan}の状態でEを押すと2年目4月になりプレイヤー1社長の
        ターンが始まる.\\
        　3年目の場合は,図\ref{shueki}および図\ref{sisan}の画面において「けっさん」と表示されている部分が「さいしゅうせいせき」
        という表示になる.また,総資産が表示された画面でEキーを押すと図\ref{quit}に示す画面が表示される.
        図\ref{quit}の画面がゲームの終了画面である.図\ref{quit}の画面でQキーを押すとプログラムの実行を終了する.
        

    \begin{figure}[H]
        \centering
        \includegraphics[scale=1.3]{sisan.eps}
        \caption{総資産の画面表示s}
         \label{sisan}
        \end{figure}

        \begin{figure}[H]
            \centering
            \includegraphics[scale=1.3]{quit.eps}
            \caption{ゲーム終了を促す画面}
             \label{quit}
            \end{figure}

        これらの動作はturnstatus=16または17のときの処理で実装している.決算はturnstatus=16,最終成績のturnstatus=17のときの処理である.
        Display関数(リスト\ref{Display})では, turnstatus=16のときprocessKessan関数, turnstatus=17のときはendgame関数を呼び出している.
        リスト\ref{processKessan}にprocessKessan関数,リスト\ref{endgame}にendgame関数のコードを示す.また,turnstatus=17のときの
        キーボード入力の処理を行うkeyboard関数のコードをリスト\ref{keyboard17}に示す.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=processKessan,caption=processKessan関数]
// 決算の処理
void processKessan(){
    int i;
    char fname[150];
    if(inflg==0){
        kessan(); // 決算処理
        // 収益を所持金に追加
        for(i=0;i<PLAYERNUM;i++){
            players[i].money+=shueki[i];
        }
        inflg++;
    }else if(inflg==1){
        // 決算のタイトル画像を表示
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[0], 0, 0, &spinfo[0],1);           
    }else if(inflg==2){
        // 背景表示
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // 決算
        drawString("keltsann",0,InitWidth/2-64,11,1);
        // しゅうえきがく
        drawString("siluuueekigaku",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
            // 名前表示
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            // 収益額表示
            drawMoney(shueki[i],InitWidth/2,75+25*i,0,0.7);
        }            
    }else if(inflg==3){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        // 背景
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // けっさん
        drawString("keltsann",0,InitWidth/2-64,11,1);
        // そうしさん
        drawString("souusisann",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
        // 名前表示
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            // 総資産表示
            drawMoney(players[i].assets+players[i].money,InitWidth/2,75+25*i,0,0.7);
        }
    }else if(inflg==4){
        inflg=0;
        year++; // 1年経過
        turnstatus=2;
    }
}
        \end{lstlisting}

        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=endgame,caption=endgame関数]
// ゲーム終了処理
void endgame(void){
    int i;
    char fname[150];
    if(inflg==0){
        kessan();
        for(i=0;i<PLAYERNUM;i++){
            players[i].money+=shueki[i];
        }
        inflg++;
    }else if(inflg==1){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[0], 0, 0, &spinfo[0],1);            
    }else if(inflg==2){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // さいしゅうせいせき
        drawString("saiisiluuuseiiseki",0,InitWidth/2-144,11,1);
        // しゅうえきがく
        drawString("siluuueekigaku",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            drawMoney(shueki[i],InitWidth/2,75+25*i,0,0.7);
        }            
    }else if(inflg==3){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // さいしゅうせいせき
        drawString("saiisiluuuseiiseki",0,InitWidth/2-144,11,1);
        // しゅうえきがく
        drawString("souusisann",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
        sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            drawMoney(players[i].assets+players[i].money,InitWidth/2,75+25*i,0,0.7);
        }
    }else if(inflg==4){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        // おつかれさまでした
        drawString("ootukaresamadesita",0,InitWidth/2-144,InitHeight/2-48,1);
        // Qでゲームをしゅうりょうします.
        drawString("xqdellgellmsllmullwosiluuurilouusimasu",0,
        InitWidth/2-120,InitHeight/2+16,0.5);          
    }
}
        \end{lstlisting}

        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=keyboard17,caption=ゲーム終了時のキーボード入力の処理]
// キーボード入力管理
void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
if(keyboardflg==0){ // キーボード入力がロックされていないとき
    
(省略)

    }else if(turnstatus==17){ // 最終成績
        if(inflg==4){
            if(key=='q'){ // ゲーム終了
                exit(0);
            }
        }else{
            if(isE(key)){
                inflg++;
            }
        }        
    }

(省略)

if(turnstatus!=5){
    keyboardflg=1; // キーボード入力ロック
    glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
}
}
}
        \end{lstlisting}

        まず,processKessan関数について説明する. inflg=0のとき,リスト\ref{processKessan}の5行目から11行目に示すように
        収益額の計算を行っている.収益額の計算はkessan関数で行っている.リスト\ref{kessancode}にkessan関数のコードを示す.
        kessan関数では,各社長について,式(\ref{kessan})に示した決算の計算式を用いて収益額の計算を行っている.
        計算結果はグローバル変数(配列)shuekiに格納している.リスト\ref{processKessan}の8行目から10行目では収益額の
        計算結果を所持金に加算する処理を行っている.これによって,4月の所持金に収益額が加算された状態になる.\\
        　inflg=1のとき,図\ref{hujisan}に示した決算開始時の画面を表示する処理を行っている. infl=2のとき,
        図\ref{shueki}に示した収益額を表示する画面の処理を行っている. 社長名と収益額を表示する処理を行っているのは
        26行目から32行目の処理である. inflg=3のとき,図\ref{sisan}に示した総資産を表示する処理を行っている.
        社長名と総資産を表示する処理を行っているのは42行目から47行目の処理である. inflg=4のとき,年を管理するyearを
        インクリメントする処理を行って,turnstatus=2,つまりターンのはじめの処理を行うようにturnstatusを更新している.
        \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=kessancode,caption=kessan関数]
// 収益計算用
int shueki[3];

// 決算処理
void kessan(void){
    int i,j,k;
    int dokusen;
    for(i=0;i<PLAYERNUM;i++){
        shueki[i]=0; // 収益初期化
        for(j=0;j<STATIONNUM;j++){
            // 独占チェック
            if(stations[j].ismonopoly==i+1){
                dokusen=2; // 独占のとき
            }else{
                dokusen=1; // 独占でないとき
            }
            for(k=0;k<stations[j].propertynum;k++){
                if(stations[j].plist[k].holder==i+1){
                    // 価格*収益率を計算
                    shueki[i]+=
                    dokusen*stations[j].plist[k].price*stations[j].plist[k].earnings/100;
                }
            }
        }
    }
}
        \end{lstlisting}

        次にendgame関数の処理について説明する. endgame関数の処理はinflg=0～3まではprocessKessan関数とほぼ同じである.
        変更点は,20行目および33行目である. processKessan関数では「けっさん」と画面に表示するようにしていたが, endgame関数
        では「さいしゅうせいせい」と表示されるようにしている. inflg=4のときの処理は画面に「おつかれさまでした.Qでゲームをしゅうりょうします.」
        と表示する処理である. inflg=4のときリスト\ref{keyboard17}の12行目から14行目の記述によって,Qキーを押すとexit関数が実行されてプログラム
        の実行が終了する.これらによって決算および最終成績の処理を実行している.

    \section{付録 ソースコード}
    本章では,次に示すソースコードについて述べる.
    \begin{enumerate}
        \item game.h
        \item game.c
    \end{enumerate}

    \subsection{game.h}
    リスト\ref{code1}にgame.hのコードを示す.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=code1,caption=game.h]
// ウィンドウサイズ
#define InitWidth 480
#define InitHeight 320
// 画像サイズ
#define IMGSIZE 32
// マップ配列のサイズ
#define XMAX 30
#define YMAX 30
// マップ画像の枚数
#define MAP_NUM 7
// イベント画像の枚数
#define SP_NUM 4
// 季節画像の枚数
#define SEASON_NUM 4

// 再描画タイマー秒数
#define RESHAPETIME 100
// 移動タイマー秒数
#define MOVETIME 100
// 乱数表示秒数
#define RANDTIME 100

// 日本語+特殊文字
#define JPMAX 75
// 特殊文字
#define SPMAX 24
// 名前の最大長
#define NAMEMAX 20
// 駅名,物件名の最大長
#define STRMAX 60

// マスIDの定義
#define PLUSMASU 0 // プラス駅
#define MINUSMASU 1 // マイナス駅
#define CARDMASU 2 // カード駅
#define PROPERTYMASU 3 // 物件駅
#define SENRO1 4 // 線路(縦)
#define SENRO2 5 // 線路(横)
#define DIST 6 // 目的地駅
#define WALL 623 // 草原

// ターン中のプレイヤーを真ん中に描画するための座標
#define CX 7
#define CY 5
#define CENTX CX*IMGSIZE
#define CENTY CY*IMGSIZE
// 一回の動く距離
#define MOVESIZE 16

// プレイヤー人数
#define PLAYERNUM 3 
// 初期プレイヤー座標
#define INITX 13*IMGSIZE
#define INITY 7*IMGSIZE
// 初期所持金
#define INITMONEY 10000

// サイコロの出目の最大値
#define DICEMAX 6
// サイコロの最大数
#define SAIKOROMAX 4
// 駅の数
#define STATIONNUM 21
// 最大物件数
#define PROPERTMAX 6
// カードの最大枚数
#define CARDMAX 5

#define CARDNUM 8
// カード番号の定義
#define KYUKO 1 // 急行カード
#define TOKKYU 2 // 特急カード
#define SINKANSEN 3 // 新幹線カード
#define SAMMIT 4 // サミットカード 
#define BUTTOBI 5 // ぶっとびカード
#define JUOKU 6 // 十億円カード
#define TOKUSEIREI 7 // 徳政令カード
#define GOUSOKKYU 8 // 剛速球カード

// 月の最大値
#define MAXMONTH 12

// プレイヤーの情報構造体
struct playerstatus{
    char name[NAMEMAX]; // プレイヤー名
    int money; // 所持金
    int assets; // 総資産
    int x; // x座標(実描画座標)
    int y; // y座標(実描画座標)
    int cardnum; // 持っているカード枚数
    int card[CARDMAX]; // カードの番号記憶
};

typedef struct playerstatus player;
player players[PLAYERNUM]; // 人数分の配列を確保

// 物件情報構造体
struct propertystatus{
    char name[STRMAX]; // 物件名
    int holder; // 物件所持者
    int price; // 価格
    int earnings; // 収益率
};

typedef struct propertystatus property;

// 駅情報構造体
struct stationstatus{
    char name[STRMAX]; // 駅名
    int x; // x座標
    int y; // y座標
    int ismonopoly; // 独占フラグ
    int propertynum; // 物件数
    property plist[PROPERTMAX]; // 物件情報構造体の配列
};

typedef struct stationstatus station;
station stations[STATIONNUM]; // 駅の数分の配列を確保
station distination; // 目的地配列

// 画像用変数
// 季節画像
GLuint seasonimg[SEASON_NUM];
pngInfo seasoninfo[SEASON_NUM];
// マップ画像
GLuint mapimg[MAP_NUM];
pngInfo mapinfo[MAP_NUM];
// プレイヤー画像
GLuint playerimg[PLAYERNUM];
pngInfo playerinfo[PLAYERNUM];
// サイコロ画像
GLuint diceimg[DICEMAX];
pngInfo diceinfo[DICEMAX];
// イベント画像
GLuint spimg[SP_NUM];
pngInfo spinfo[SP_NUM];

// 日本語画像
// ひらがな黒
GLuint hblackimg[JPMAX+SPMAX];
pngInfo hblackinfo[JPMAX+SPMAX];
// ひらがな赤
GLuint hredimg[JPMAX+SPMAX];
pngInfo hredinfo[JPMAX+SPMAX];
// カタカナ黒
GLuint kblackimg[JPMAX];
pngInfo kblackinfo[JPMAX];
// カタカナ赤
GLuint kredimg[JPMAX];
pngInfo kredinfo[JPMAX];

// 月,年,季節
int month,year,season;
// 誰のターンか判別
int turn;
// ターンの状況
int turnstatus;
int inflg;
// ゴールフラグ
int goalflg;
// 向き
int direction;
// 次の停車位置座標
int nx;
int ny;
// ターン中のプレイヤーを真ん中に描くための変数
int tx,ty;

// キーボードフラグ
int keyboardflg;
// 残り移動可能マス
int recount;

//サイコロの数
int saikoro;
int rcard;
int nextflg;

// 乱数生成用
int randflg;
int range;
int randresult;
int randresulttmp[SAIKOROMAX];
int dummynum;
int dummyresult[SAIKOROMAX];

// 収益計算用
int tmpmoney;
// 借金計算用 
int rdebet;

// 物件を買うときの変数
// 選択ポジション
int selectpos;
// 駅のインデックス
int stid;
// 物件数
int propertynum;

// 移動したマスを記録
int massRecord[DICEMAX*SAIKOROMAX][2];

void Reshape(int, int);
void PutSprite(int, int, int, pngInfo *,double);
void Timer(int);
void keyboardTimer(int);
void MoveTimer(int);
void RandTimer(int);

int getmapnum(int,int);
int isMovable(int,int);
void move(void);
void nextStation(int,int);
void dispmassRecord(void);

void readImg(void);
void readStation(void);
void readProperty(void);

void drawMap(void);
void drawPlayer(void);
void drawChar(int,int,int,int,int,double);
void drawString(char *,int,int,int,double);
void drawDialog(int,int,int,int);
void drawQUAD(int,int,int,int);
void drawMoney(int,int,int,int,double);
void drawText(char *,int,int,int,int,int);
void drawStation(void);

void Initvalue(void);
void InitPlayer(void);

void keyboard(unsigned char,int x,int y);
void calseason(void);
int sale(int,int);
void kessan(void);
int debtprocess(void);
void Display(void);

void Initvalue(void);
void startgame(void);
void desisionDist(void);
void startTurn(void);
void rollDice(void);
void moveMass(void);
void checkMass(void);
void purchaseProperty(void);
void plusMass();
void minusMass(void);
void cardMass(void);
void endTurn(void);
void processKessan();
void endgame(void);

void dispPlayer(int);
void dispStation(int);
    \end{lstlisting}

    \subsection{game.c}
    リスト\ref{code2}にgame.cのコードを示す.
    \begin{lstlisting}[basicstyle=\ttfamily\footnotesize, frame=single,label=code2,caption=game.c]
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// 17406 408 金澤雄大 ちゃま鉄 version delta                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
//    ____   _                                   _            _             //
//   / ___| | |__     __ _   _ __ ___     __ _  | |_    ___  | |_   _   _   //
//  | |     | '_ \   / _` | | '_ ` _ \   / _` | | __|  / _ \ | __| | | | |  //
//  | |___  | | | | | (_| | | | | | | | | (_| | | |_  |  __/ | |_  | |_| |  //
//   \____| |_| |_|  \__,_| |_| |_| |_|  \__,_|  \__|  \___|  \__|  \__,_|  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////                                                                       

#include <GL/glut.h>
#include <GL/glpng.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include "game.h"

// マップ配列
char Map[YMAX][XMAX+1] = { //NULL文字に気を付ける
       //012345678901234567890123456789      
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", // 0
        "AAAAAAAAAAAP-M--M-BAAAAAAAAAAA", // 1
        "AAAAAAAAAAA|A|AAAAAAAAAAAAAAAA", // 2
        "AAAAAAAAAC-M-BAAAAAAAAAAAAAAAA", // 3
        "AAAAAAAAA|AAA|AAAAAAAAAAAAAAAA", // 4
        "AAAAAAAAAP-M-P--CAAAAAAAAAAAAA", // 5
        "AAAAAAAAA|AAA|AA|AAAAAAAAAAAAA", // 6
        "AAAB-C---C---B--P--BAAAAAAAAAA", // 7
        "AAA|AAAAA|AAAAAA|AA|AAAAAAAAAA", // 8
        "AAAMAAAAABAAAAAAM--P-CAAAAAAAA", // 9
        "AAA|AAAAA|AABAAAAAA|A|AAAAAAAA", // 0
        "AAAM-MAAA|AA|AAAAAAB-CAAAAAAAA", // 1
        "AAA|A|AAAB--M--PAAA|AAAAAAAAAA", // 2
        "AAAM-MAAA|AAAAAAAAAMAAAAAAAAAA", // 3
        "AAA|AAAAA|AAAAAAAAA|AAAAAAAAAA", // 4
        "AAA|AAAAAB-P-M-M-P-B-P-BAAAAAA", // 5
        "AAAMAAAAA|AAA|AAAAAAAAA|AAAAAA", // 6
        "AAA|AAAAAPAAAPAAAAAAAAA|AAAAAA", // 7
        "AAAB-MAAA|AAA|AAAAAAAAABAAAAAA", // 8
        "AAA|AAAAAP---CAAAAAAAAA|AAAAAA", // 9
        "AAABAAAAA|AAAAAAAAAAAAA|AAAAAA", // 0
        "AAA|AAAAA|AAAAAAAAAAAAA|AAAAAA", // 1
        "AAAM-M---B--C--P-MAAAAA|AAAAAA", // 2
        "AAAAAAAAA|AAAAAAA|AAP--PAAAAAA", // 3
        "AAAAAAAAA|AAAAAAA|AA|AA|AAAAAA", // 4
        "AAABAC-M-C-----M-B--C--P--PAAA", // 5
        "AAA|A|A|A|AAAAA|A|AAAAA|AAAAAA", // 6
        "AAAM-P-P-B-CAAA|A|AAAAABAAAAAA", // 7
        "AAAAAAAAAAAAAAAM-P--BAAAAAAAAA", // 8
        "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"  // 9
};

// 日本語プロトコル
char jpProtcol[JPMAX+SPMAX][3] = {"aa","ii","uu","ee","oo",
                            "ka","ki","ku","ke","ko",
                            "sa","si","su","se","so",
                            "ta","ti","tu","te","to",
                            "na","ni","nu","ne","no",
                            "ha","hi","hu","he","ho",
                            "ma","mi","mu","me","mo",
                            "ya","yu","yo",
                            "ra","ri","ru","re","ro",
                            "wa","wo","nn",
                            "lt","la","lu","lo",
                            "ga","gi","gu","ge","go",
                            "za","zi","zu","ze","zo",
                            "da","di","du","de","do",
                            "ba","bi","bu","be","bo",
                            "pa","pi","pu","pe","po",
                            "0","1","2","3","4","5"
                            ,"6","7","8","9",
                            "ex","mx","ox","px","ms","ps",
                            "mr","tn","xq","xw","xe","xa","xs","xd"
                            };

// プレイヤーカラー
int playercolor[3][3]={{30,144,255},
                       {255,20,147},
                       {255,255,0}};
// プラス駅の色
int pluscolor[3] = {0,0,205};

// マイナス駅の色
int minuscolor[3] = {220,20,60};

// カード駅の色
int cardcolor[3] = {255,255,33};

// プラス駅の月別乱数表
int plusarray[MAXMONTH][2] = {{400,1200}, // 1月
                               {200,800}, // 2月
                               {400,1500}, // 3月
                               {2000,4000}, // 4月
                               {3000,7000}, // 5月
                               {4000,8000}, // 6月
                               {12000,30000}, // 7月
                               {35000,70000}, // 8月
                               {18000,32000}, // 9月
                               {6000,12000}, // 10月
                               {3000,7000}, // 11月
                               {2000,4000}}; // 12月

// マイナス駅の月別乱数表
int minusarray[MAXMONTH][2] = {{10000,25000}, // 1月
                               {20000,80000}, // 2月
                               {10000,25000}, // 3月
                               {500,1500}, // 4月
                               {400,1200}, // 5月
                               {300,1000}, // 6月
                               {200,600}, // 7月
                               {100,400}, // 8月
                               {500,1500}, // 9月
                               {2000,4000}, // 10月
                               {3000,8000}, // 11月
                               {4000,9000}}; // 12月

char cardname[CARDNUM][50]={"kiluuukouullkallmslldoll",
                         "toltkiluuullkallmslldoll",
                         "sinnkannsennllkallmslldoll",
                         "llsamilttokallmslldoll",
                         "bulttobillkallmslldoll",
                         "10oxexllkallmslldoll",
                         "tokuseiireiillkallmslldoll",
                         "gouusoltkiluuullkallmslldoll"};
// 収益計算用
int shueki[3];

// デバッグ用関数 	
// プレイヤー構造体を表示	
// detail : 0 全部表示 , else その番号の駅を表示	
void dispPlayer(int detail){	
    int i,j;	
    if(detail==0){	
        for(i=0;i<PLAYERNUM;i++){	
            printf("--------------------\n");	
            printf("%s社長 (%d,%d)\n",players[i].name,players[i].x,players[i].y);	
            printf("\n");	
            printf("所持金 : %d\n",players[i].money);	
            printf("総資産 : %d\n",players[i].assets);
            printf("カード枚数 : %d\n",players[i].cardnum);
            for(j=0;j<CARDMAX;j++){
                printf("%d ",players[i].card[j]);
            }	
            printf("\n--------------------\n\n");	
        }	
    }else{	
        printf("--------------------\n");	
        printf("%s社長 (%d,%d)\n",players[detail-1].name,players[detail-1].x,
        players[detail-1].y);	
        printf("\n");	
        printf("所持金 : %d\n",players[detail-1].money);	
        printf("総資産 : %d\n",players[detail-1].assets);
        printf("カード枚数 : %d\n",players[detail-1].cardnum);
        for(j=0;j<CARDMAX;j++){
            printf("%d ",players[detail-1].card[j]);
        }		
        printf("\n--------------------\n\n");   	
    }	
}

// デバッグ用関数	
// 駅情報を表示	
void dispStation(int detail){	
    int i,j;	
    if(detail==0){	
        for(i=0;i<STATIONNUM;i++){	
            printf("--------------------\n");	
            printf("%s駅 (%d,%d)\n",stations[i].name,stations[i].x,stations[i].y);	
            printf("独占フラグ : %d   物件数 : %d\n",stations[i].ismonopoly,
            stations[i].propertynum);	
            for(j=0;j<stations[i].propertynum;j++){	
                printf("%s %d %d %d\n",stations[i].plist[j].name,stations[i].plist[j].price,
                stations[i].plist[j].earnings,stations[i].plist[j].holder);	
            }	
            printf("--------------------\n\n");	
        }	
        }else{	
        printf("--------------------\n");	
        printf("%s駅 (%d,%d)\n",stations[detail-1].name,stations[detail-1].x,
        stations[detail-1].y);	
        printf("独占フラグ : %d   物件数 : %d\n",stations[detail-1].ismonopoly,
        stations[detail-1].propertynum);	
        for(j=0;j<stations[detail-1].propertynum;j++){	
            printf("%s %d %d %d\n",stations[detail-1].plist[j].name,
            stations[detail-1].plist[j].price,stations[detail-1].plist[j].earnings,
            stations[detail-1].plist[j].holder);	
        }	
        printf("--------------------\n\n");     	
    }	
}

// (x,y)に大きさscaleの画像を表示
void PutSprite(int num, int x, int y, pngInfo *info,double scale)
{
    int w, h;  //  テクスチャの幅と高さ

    w = info->Width*scale;   //  テクスチャの幅と高さを取得する
    h = info->Height*scale;

    glPushMatrix();
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, num);
    glColor4ub(255, 255, 255, 255);

    glBegin(GL_QUADS);  //  幅w, 高さhの四角形

    glTexCoord2i(0, 0); 
    glVertex2i(x, y);

    glTexCoord2i(0, 1);
    glVertex2i(x, y + h);

    glTexCoord2i(1, 1);
    glVertex2i(x + w, y + h);

    glTexCoord2i(1, 0);
    glVertex2i(x + w, y);

    glEnd();

    glDisable(GL_TEXTURE_2D);
    glPopMatrix();
}

// ウィンドウサイズ変更時の処理
void Reshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluOrtho2D(0, w, 0, h);
    glScaled(1, -1, 1);
    glTranslated(0, -h, 0);
    //windowサイズ固定 
    glutReshapeWindow(InitWidth,InitHeight);
}

// 画面更新用タイマー
void Timer(int t)
{
    glutPostRedisplay();
    glutTimerFunc(RESHAPETIME, Timer, 0);
}

// ダミー乱数を一定時間ごとに生成するタイマー
void RandTimer(int t)
{ // (0,range-1)の範囲の乱数を生成
    int i;
    for(i=0;i<dummynum;i++){
        dummyresult[i] = rand()%range;
    }
    if(randflg==1){ // randflgがたっているときタイマー継続
        glutTimerFunc(RANDTIME, RandTimer, 0);
    }
}

// 駅移動管理タイマー
void MoveTimer(int t)
{
    int transx;
    int transy;
    // 移動処理
    move();
    // 座標変換
    transx = players[turn].x/IMGSIZE;
    transy = players[turn].y/IMGSIZE;
    if((transx != nx)||(transy != ny)){ // 次の駅の座標と同じか
        glutTimerFunc(MOVETIME, MoveTimer, 0); // 同じでないときタイマー継続
    }else if((players[turn].x%IMGSIZE!=0)||(players[turn].y%IMGSIZE!=0)){  
        // 余りが0でないとき
        glutTimerFunc(MOVETIME, MoveTimer, 0); // タイマー継続
    }else{
        if(randresult-recount>0){ // まだ移動可能かどうか
        // 移動可能のとき,以前の移動履歴をチェック
            if((massRecord[randresult-recount-1][0]==transx)&&
            (massRecord[randresult-recount-1][1]==transy)){
                recount++; // 戻ったとき残りカウント数増加
            }else{
                recount--; // 進んだとき残りカウント数減少
            }
        }else{
            recount--; // カウント減少
        }
        if(recount==0){ // カウント終了のときキーボード入力をロック
            keyboardflg=1;
        }else{ // キーボード入力のロックを解除
            keyboardflg=0;
        }
    }
}


//キーボード入力管理タイマー 
void keyboardTimer(int t)
{
    // キーボード入力ロックを解除
    keyboardflg=0;
}

// eを押したか判定
// 1: キーがE
// 0 : キーがEでない
int isE(unsigned char key){
    if(key=='e'){
        return 1;
    }else{
        return 0;
    }
}

// 行先が壁かどうか判定
// 1 : 壁
// 0 : 壁でない
int isWall(int x,int y){
    if(getmapnum(x,y)==WALL){
        return 1;
    }
    return 0;
}

// 0 : 上
// 1 : 右
// 2 : 下
// 3 : 左 
//
// 進めるとき 1
// 進めないとき 0
int isMovable(int x,int y){
    if(direction==0){ // 上
        if(isWall(x,y-1)){
            return 0;
        }
    }else if(direction==1){ //右
        if(isWall(x+1,y)){
            return 0;
        }    
    }else if(direction==2){ //下
        if(isWall(x,y+1)){
            return 0;
        }   
    }else{ //左
        if(isWall(x-1,y)){
            return 0;
        }   
    }
    return 1;
}

// 移動処理
void move(void){
    if(direction==0){ // 上
        players[turn].y-=MOVESIZE;
    }
    if(direction==1){ // 右
        players[turn].x+=MOVESIZE;
    }
    if(direction==2){ // 下
        players[turn].y+=MOVESIZE;
    }
    if(direction==3){ // 左
        players[turn].x-=MOVESIZE;
    }
}

// 次の駅を取得
void nextStation(int x,int y){
    int sx=x;
    int sy=y;
    if(direction==0){ // 上
        while(1){
            sy--;
            if(getmapnum(sx,sy)!=SENRO1){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==1){ // 右
        while(1){
            sx++;
            if(getmapnum(sx,sy)!=SENRO2){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==2){ // 下
        while(1){
            sy++;
            if(getmapnum(sx,sy)!=SENRO1){ // 駅を発見したら
                break;
            }
        }
    }else if(direction==3){ // 左
        while(1){
            sx--;
            if(getmapnum(sx,sy)!=SENRO2){ // 駅を発見したら
                break;
            }
        }
    }else{ // エラーチェック用
        sx=-623;
        sy=-623;
    }
    // 次の駅の座標をセット
    nx=sx;
    ny=sy;
}

// 物件が購入できるか取得
// 1 : 取得可能
// 0 : 取得不可能
int ispurchase(int id){
    int flg=1;
    // 既に誰かの物件のとき
    if(stations[stid].plist[id].holder!=0){
        flg=0;
    }
    // 値段が足りないとき
    if(players[turn].money < stations[stid].plist[id].price){ 
        flg=0;
    }
    return flg;
}

//物件購入処理
void purchase(int id){
    int i;
    int monopolyCheck=0; // 独占チェック用
    // 総資産を計算
    players[turn].assets+=stations[stid].plist[selectpos].price;
    // 所持金を計算
    players[turn].money-=stations[stid].plist[selectpos].price;
    // 購入済みフラグをたてる
    stations[stid].plist[selectpos].holder=turn+1;    
    // 独占チェック
    for(i=0;i<propertynum;i++){
        if(stations[stid].plist[i].holder==turn+1){
            monopolyCheck++;
        }
    }    
    // 独占のとき
    if(monopolyCheck==propertynum){
        // 独占フラグをたてる
        stations[stid].ismonopoly=turn+1;
    }    
}

// 画像読み込み
void readImg(void){
    int i;
    char fname[100];

    // イベントマップ読み込み
    for(i=0;i<SP_NUM;i++){
        sprintf(fname,".\\eventparts\\sp%d.png",i+1);
        spimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &spinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);        
    }

   // 季節マップ読み込み 
    for(i=0;i<SEASON_NUM;i++){
        sprintf(fname,".\\mapparts\\season%d.png",i+1);
        seasonimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &seasoninfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);        
    }

    // マップイメージ読み込み
    for(i=0;i<=MAP_NUM;i++){
        sprintf(fname,".\\mapparts\\map%d.png",i+1);
        mapimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &mapinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // プレイヤー画像を読み込み
    for(i=0;i<PLAYERNUM;i++){
        sprintf(fname,".\\eventparts\\player%d.png",i+1);
        playerimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &playerinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }

    // サイコロの画像を読み込み
    for(i=0;i<DICEMAX;i++){
        sprintf(fname,".\\dice\\dice%d.png",i+1);
        diceimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
       &diceinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Hiragana black
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\h%sblack.png",jpProtcol[i]);
        hblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }

    // read Hiragana red
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\h%sred.png",jpProtcol[i]);
        hredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Katakana black
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\k%sblack.png",jpProtcol[i]);
        kblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &kblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Katakana red
    for(i=0;i<JPMAX;i++){
        sprintf(fname,".\\charimg\\k%sred.png",jpProtcol[i]);
        kredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &kredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Special Str red
    for(i=JPMAX;i<JPMAX+SPMAX;i++){
        sprintf(fname,".\\charimg\\%sred.png",jpProtcol[i]);
        hredimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hredinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
    // read Special Str black
    for(i=JPMAX;i<JPMAX+SPMAX;i++){
        sprintf(fname,".\\charimg\\%sblack.png",jpProtcol[i]);
        hblackimg[i] = pngBind(fname, PNG_NOMIPMAP, PNG_ALPHA, 
        &hblackinfo[i], GL_CLAMP, GL_NEAREST, GL_NEAREST);
    }
}

// ファイルから駅情報を取得
// stations構造体を初期化
void readStation(void){
    FILE *fp;
    int i=0;
    fp=fopen("property.txt","r");
    if(fp==NULL){ // 開けなかったとき
        printf("file not found");
        exit(0);
    }else{ // 駅名と座標を取得
        while(fscanf(fp,"%s %d,%d",stations[i].name,&stations[i].x,&stations[i].y)!=EOF){
            stations[i].ismonopoly=0; // 独占フラグ初期化
            i++;
        }
        fclose(fp);
    }
}

// ファイルから物件情報を取得
void readProperty(void){
    FILE *fp;
    int i,j;
    char fname[100];
    for(i=0;i<STATIONNUM;i++){
        sprintf(fname,".\\property\\%s.txt",stations[i].name);
        fp=fopen(fname,"r");
        j=0;
        if(fp==NULL){ // 開けなかったとき
            printf("file not found in %s",stations[i].name);
            exit(0);
        }else{
            // 物件名,値段,収益率を取得
            while(fscanf(fp,"%s %d,%d",stations[i].plist[j].name,
            &stations[i].plist[j].price,&stations[i].plist[j].earnings)!=EOF){
            stations[i].plist[j].holder=0; // 購入フラグ初期化
            j++;
        }
        stations[i].propertynum=j; // 物件数を保存
        fclose(fp);
    }

    }   
}

// マップの画像番号を取得
int getmapnum(int x,int y){
    int img_num;
    // 配列番号をはみ出した場合
    if((x<0)||(x>=XMAX)){ 
        return 623; // 草原マップを返す
    }else if((y<0)||(y>=YMAX)){
        return 623; // 草原マップを返す
    }

    switch (Map[y][x]){
    case 'A': // 草原
        img_num=623;
        break;
    case 'B': // 物件
        img_num=3;
         break;
    case '|': // 線路(縦)
        img_num=4;
        break; 
    case '-': // 線路(横)
        img_num=5;
        break;
    case 'P': // プラス駅
        img_num=0;
        break;
    case 'M': // マイナス駅
        img_num=1;
        break;
    case 'C': // マイナス駅
        img_num=2;
        break;
    }
    return img_num;
}

// マップを描画
void drawMap(void){
    int x,y;
    int drawx,drawy;
    int img_num;
    for(y=0;y<InitHeight/IMGSIZE;y++){
        for(x=0;x<InitWidth/IMGSIZE;x++){
            drawx = x*IMGSIZE;
            drawy = y*IMGSIZE;
            img_num = getmapnum(x+tx,y+ty);
            if((distination.x==x+tx)&&(distination.y==y+ty)){ // 目的地のとき
                // 目的地画像を描画
                PutSprite(mapimg[DIST], drawx, drawy, &mapinfo[DIST],1);
            }else if(img_num==WALL){ // 草原マップのとき
                // 季節にあった草原を描画
                PutSprite(seasonimg[season], drawx, drawy, &seasoninfo[season],1);
            }else{
                // マップ描画
                PutSprite(mapimg[img_num], drawx, drawy, &mapinfo[img_num],1);
            }
        }
    }
}

// プレイヤーを描画
// 最上面にターン中のプレイヤーを描画
void drawPlayer(void){
    int transx,transy;
    int i;
    for(i=0;i<PLAYERNUM;i++){
        if(i!=turn){ // ターン中のプレイヤー以外を描画
            transx = players[i].x/IMGSIZE;
            transy = players[i].y/IMGSIZE;
            PutSprite(playerimg[i], (transx-tx)*IMGSIZE,
            (transy-ty)*IMGSIZE, &playerinfo[i],1);
        }
    }
    // ターン中のプレイヤーを最上レイヤーに表示
    PutSprite(playerimg[turn], CENTX,CENTY, &playerinfo[turn],1);
}

// 1文字の日本語を表示
// int kh : 0,Hiragana 1,Katakana
// int color 0,black 1,red
void drawChar(int num,int kh,int color,int x,int y,double scale){
    if(kh==0){
        if(color==0){ // hiragana black
            PutSprite(hblackimg[num], x, y, &hblackinfo[num],scale);
        }else{ //hiragana red
            PutSprite(hredimg[num], x, y, &hredinfo[num],scale);
            }
        }else{ 
        if(color==0){ // katakana black
            PutSprite(kblackimg[num], x, y, &kblackinfo[num],scale);
        }else{ // katakana red
            PutSprite(kredimg[num], x, y, &kredinfo[num],scale);
        }
    }
}

// 引数stringの文字列を表示
void drawString(char *string,int color,int xo,int yo,double scale){
    int i,j;
    int len = strlen(string);
    int x=xo;
    int y=yo;
    int flg;
    int kh=0;
    for(i=0;i<len;i++){
        flg=string[i]-'0'; // インデクス計算
        if((flg>=0)&&(flg<=9)){ // 数字描画
            drawChar(JPMAX+flg,0,color,x,y,scale);
            flg=1;
        }else{
            for(j=0;j<JPMAX;j++){ //日本語描画
                if((jpProtcol[j][0]==string[i])&&(jpProtcol[j][1]==string[i+1])){
                    drawChar(j,kh,color,x,y,scale);
                    break;
                }
            }       
            for(j=JPMAX+10;j<JPMAX+SPMAX;j++){ //特殊文字描画
                if((jpProtcol[j][0]==string[i])&&(jpProtcol[j][1]==string[i+1])){
                    drawChar(j,kh,color,x,y,scale);
                    break;
                }
            }
            flg=1;
            if((string[i]=='l')&&(string[i+1]=='l')){ //ひらがな/カタカナ切り替え
                kh=1-kh;
                flg=0;
            }
            if((string[i]=='x')&&(string[i+1]=='x')){ // 改行
                x=xo;
                flg=0;
                y+=IMGSIZE*scale;
            }     
            i++;
        }
        if(flg==1){ // 次の座標に移動
            x+=IMGSIZE*scale;
            if(x>InitWidth-22){
                x=xo;
                y+=IMGSIZE*scale;
            }
        }
    }
}

// プレイヤー構造体を初期化
void InitPlayer(void){
    int i,j;
    for(i=0;i<PLAYERNUM;i++){
        //プレイヤーhoge
        sprintf(players[i].name,"llpureiiyallms%d",i+1);
        players[i].x=INITX;
        players[i].y=INITY;
        players[i].money= INITMONEY;
        players[i].assets=0;
        players[i].cardnum=0;
        for(j=0;j<CARDMAX;j++){
            players[i].card[j]=0;
        }
    }
}

// ダイアログを画面に描画
void drawDialog(int x,int y,int width,int height){
    // ダイアログの背景を描画
    glBegin(GL_QUADS);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();

    // 外側の四角を縁取り
    glColor3ub(139,69,19);
    glBegin(GL_LINE_LOOP);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();

    // 内側の四角を縁取り
    glBegin(GL_LINE_LOOP);
    glVertex2i(x+5,y+5);
    glVertex2i(x+5,y+height-5);
    glVertex2i(x+width-5,y+height-5);
    glVertex2i(x+width-5,y+5);
    glEnd();
}

// 数字を描画
void drawMoney(int money,int x,int y,int color,double scale){
    char fname[50];
    int oku,man;
    // 億の桁,万の桁を計算
    oku = money/10000;
    man = money%10000;
    if(money>=0){ // お金がプラスの時
        if(oku!=0){
            if(man!=0){
                sprintf(fname,"%dox%dmxex",oku,man);
            }else{
                sprintf(fname,"%doxex",oku);
            }
        }else{
            sprintf(fname,"%dmxex",man);
        }
    }else{ // お金がマイナスの時
    // 数字部分の符号を反転
        oku*=-1;
        man*=-1;
        if(oku!=0){
            if(man!=0){
                sprintf(fname,"ms%dox%dmxex",oku,man);
            }else{
                sprintf(fname,"ms%doxex",oku);
            }
        }else{
            sprintf(fname,"ms%dmxex",man);
        }        
    }
    // 画面出力
    drawString(fname,color,x,y,scale);
}

// 四角形を描画
void drawQUAD(int x,int y,int width,int height){
    glBegin(GL_QUADS);
    glVertex2i(x,y);
    glVertex2i(x,y+height);
    glVertex2i(x+width,y+height);
    glVertex2i(x+width,y);
    glEnd();       
}

// テキスト表示
void drawText(char *string,int x,int y,int width,int height,int color){
    glColor3ub(255,245,238);
    drawDialog(x,y,width,height);
    drawString(string,color,x+5,y+5,0.5);
}

// 物件情報を描画
void drawStation(void){
    char fname[100];
    int i,j;
    int holder;
    int color;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
    // どの駅か識別
    for(i=0;i<STATIONNUM;i++){
        // 駅の座標が一致したら
         if((stations[i].x==transx)&&(stations[i].y==transy)){
            // 物件数を取得
            propertynum = stations[i].propertynum; 
            // 配列番号を取得
            stid = i;
         }
     }
    
    // 駅名表示
    glColor3ub(255,245,238);
    drawDialog(11,11,InitWidth-22,42);
    sprintf(fname,"%seeki",stations[stid].name);
    drawString(fname,0,16,16,1);
    
    // 所持金表示
    glColor3ub(playercolor[turn][0],playercolor[turn][1],playercolor[turn][2]);
    drawDialog(11,61,InitWidth-22,34);
    drawString("silozikinn",0,16,61+8,0.5);
    drawMoney(players[turn].money,2*InitWidth/4,61+8,0,0.5);
    
    // 物件表示
    glColor3ub(255,245,238);
    drawDialog(11,103,InitWidth-22,11+17*stations[stid].propertynum);
    for(j=0;j<propertynum;j++){
        
        // 収益率を文字列に変換
        sprintf(fname,"%dpx",stations[stid].plist[j].earnings);
        
        // 物件の所有者がいるとき,所有者カラーで物件を囲む
        holder = stations[stid].plist[j].holder;
        if(holder!=0){
            glColor3ub(playercolor[holder-1][0],playercolor[holder-1][1],
            playercolor[holder-1][2]);
            drawQUAD(16,108+j*17,InitWidth-32,17);
        }

        // セレクトポジションを表示
        if(selectpos == j){
            glColor3ub(255,0,0);
            drawQUAD(16,108+j*17,InitWidth-32,17);                 
        }
        // 物件の表示色設定
        if(ispurchase(j)){
            color=0;
        }else{
            color=1;
        }
        // 物件を表示
        drawString(stations[stid].plist[j].name,color,18,42+11+50+7+17*j,0.5);
        drawMoney(stations[stid].plist[j].price,InitWidth/2-16,42+11+50+7+17*j,color,0.5);
        drawString(fname,color,16+3*InitWidth/4,42+11+50+7+17*j,0.5);
    }
    // 独占ダイアログ表示
    if(stations[stid].ismonopoly!=0){
        sprintf(fname,"%ssilatilouunodokusenndesumr",
        players[stations[stid].ismonopoly-1].name);
        drawText(fname,11,223,InitWidth-22,32,0);
        sprintf(fname,"xqsssiluuurilouuxxxesskouuniluuu");
        drawText(fname,11,273,InitWidth-22,42,0);
    }else{ // 操作ダイアログ表示
            sprintf(fname,"xqsssiluuurilouuxxxesskouuniluuu");
            drawText(fname,11,225,InitWidth-22,42,0);
    }
}

// 決算処理
void kessan(void){
    int i,j,k;
    int dokusen;
    for(i=0;i<PLAYERNUM;i++){
        shueki[i]=0; // 収益初期化
        for(j=0;j<STATIONNUM;j++){
            // 独占チェック
            if(stations[j].ismonopoly==i+1){
                dokusen=2; // 独占のとき
            }else{
                dokusen=1; // 独占でないとき
            }
            for(k=0;k<stations[j].propertynum;k++){
                if(stations[j].plist[k].holder==i+1){
                    // 価格*収益率を計算
                    shueki[i]+=
                    dokusen*stations[j].plist[k].price*stations[j].plist[k].earnings/100;
                }
            }
        }
    }
}

// キーボード入力管理
void keyboard(unsigned char key,int x,int y){
    int locktime =500;
    int transx = players[turn].x/IMGSIZE;
    int transy = players[turn].y/IMGSIZE;
if(keyboardflg==0){ // キーボード入力がロックされていないとき
    if(turnstatus==0){ //タイトル
        if(isE(key)){
            inflg++;
        }
    }else if(turnstatus==1){ // 目的地設定
        if(isE(key)){
            inflg++;
        }
    }else if(turnstatus==2){ // ターンのはじめ
    if(inflg==1){
        if(key=='w'){
            if(selectpos==1){
                selectpos=0;
            }   
        }else if(key=='s'){
            if(selectpos==0){
                selectpos=1;
            }
        }else if(isE(key)){
            inflg++;
        }
    }else if(inflg==4){
        if(isE(key)){
            inflg=1;
        }        
    }else if(inflg==5){
        if(key=='w'){
            if(selectpos>=1){
                selectpos--;
            }   
        }else if(key=='s'){
            if(selectpos<players[turn].cardnum){
                selectpos++;
            }
        }else if(isE(key)){
            inflg++;
        }        
    }else{
        if(isE(key)){
            inflg++;
        }        
    }
    }else if(turnstatus==4){ // サイコロをふるとき
        if(isE(key)){
            inflg++;
        }
    }else if(turnstatus==5){ //移動
        if(key=='w'){ // 上
            direction=0;
        }else if(key=='d'){ // 右
            direction=1;
        }else if(key=='s'){ // 下
            direction=2;
        }else if(key=='a'){ // 左
            direction=3;
        }else { // それ以外
            direction=-623;
        }
        if(direction!=-623){
            if(isMovable(transx,transy)){
                // 移動履歴を書き込み
                massRecord[randresult-recount][0]=transx;
                massRecord[randresult-recount][1]=transy;
                // 次の駅を計算
                nextStation(transx,transy);
                keyboardflg=1; // キーボード入力ロック
                glutTimerFunc(MOVETIME, MoveTimer, 0); //移動タイマー起動
            }
        }   
    }else if(turnstatus==6){ // 到着
        if(inflg>=1){
            inflg++;
        }
    }else if(turnstatus==7){ // 物件購入
        locktime=200;
        if(key=='s'){ // ポジションを下へ
            if(selectpos<propertynum-1){
                selectpos+=1;
            }            
        }else if(key=='w'){ // ポジションを上へ
            if(selectpos>=1){
                selectpos-=1;
            }            
        }else if(isE(key)){ //　物件購入
            if(ispurchase(selectpos)){
                purchase(selectpos);
            }
        }else if(key=='q'){ // 購入終了
                inflg++;
        }
    }else if(turnstatus==8){ // プラスマス
        if(isE(key)){
            inflg++;
        }        
    }else if(turnstatus==9){ // マイナスマス
        if(isE(key)){
            inflg++;
        }        
    }else if(turnstatus==10){ // カードマス
        if(isE(key)){
            inflg++;
        }        
    }else if(turnstatus==16){ // 決算
        if(isE(key)){
            inflg++;
        }        
    }else if(turnstatus==17){ // 最終成績
        if(inflg==4){
            if(key=='q'){ // ゲーム終了
                exit(0);
            }
        }else{
            if(isE(key)){
                inflg++;
            }
        }        
    }

    if(turnstatus!=5){
        keyboardflg=1; // キーボード入力ロック
        glutTimerFunc(locktime, keyboardTimer, 0); // ロック解除タイマー
    }
}
}

// 物件を売却する関数
//ismonopoly : 独占の物件を売るか
// high : 借金より高い物件から売るか
int sale(int ismonopoly,int high){
    int i,j;
    int nearest=99999;
    int nearestst=-1;
    int nearestid=-1;
    int count=0;
    while(1){
        for(i=0;i<STATIONNUM;i++){ // 全ての駅について
            if(ismonopoly){ // 独占の物件を売るとき
                for(j=0;j<stations[i].propertynum;j++){ // 全ての物件について
                    if(stations[i].plist[j].holder==turn+1){ 
                        // ターン中のプレイヤーの物件のとき
                        // 物件の価格が借金の絶対値より大きいとき
                        if(high){
                        // 借金より高い物件かチェック
                        if(stations[i].plist[j].price>=-players[turn].money){
                            // 値段が近いとき
                            if(abs(-players[turn].money-stations[i].plist[j].price)
                            <nearest){
                                // 候補として更新
                                nearest = 
                                abs(-players[turn].money-stations[i].plist[j].price);
                                nearestst = i;
                                nearestid = j;                              
                            }
                        }
                        }else{
                            // 値段が近いとき
                            if(abs(-players[turn].money-stations[i].plist[j].price)
                            <nearest){
                                // 候補として更新
                                nearest = 
                                abs(-players[turn].money-stations[i].plist[j].price);
                                nearestst = i;
                                nearestid = j;                              
                            }
                        }
                    }
                }
            }else{
                if(stations[i].ismonopoly!=turn+1){ // 独占でないとき
                for(j=0;j<stations[i].propertynum;j++){ // 全ての物件について
                    if(stations[i].plist[j].holder==turn+1){ 
                        // ターン中のプレイヤーの物件のとき
                        // 物件の価格が借金の絶対値より大きいとき
                        if(high){
                        // 借金より高い物件かチェック
                        if(stations[i].plist[j].price>=-players[turn].money){
                            // 値段が近いとき
                            if(abs(-players[turn].money-stations[i].plist[j].price)
                            <nearest){
                                // 候補として更新
                                nearest = 
                                abs(-players[turn].money-stations[i].plist[j].price);
                                nearestst = i;
                                nearestid = j;                                 
                            }
                        }
                        }else{
                            // 値段が近いとき
                            if(abs(-players[turn].money-stations[i].plist[j].price)
                            <nearest){
                                // 候補として更新
                                nearest = 
                                abs(-players[turn].money-stations[i].plist[j].price);
                                nearestst = i;
                                nearestid = j;                                 
                            }
                        }
                    }
                }
            }
            }
        }
        if(nearestst==-1){ // 売れる物件がない
            break;
        }else{
            count++; // 売った物件の数を追加
             // 購入フラグ解除
            stations[nearestst].plist[nearestid].holder=0;
            // 所持金を計算
            players[turn].money+=stations[nearestst].plist[nearestid].price;
            // 総資産を計算
            players[turn].assets-=stations[nearestst].plist[nearestid].price;
            // 借金が回復したとき
            if(players[turn].money>=0){
                return count;
            }
        }      
    }
    return count;
}

//季節番号を計算
// 0:春 3~5月
// 1:夏 6~8月
// 2:秋 9~11月
// 3:冬 12~2月
void calseason(void){
    if((3<=month)&&(month<=5)){
        season=0;
    }else if((6<=month)&&(month<=8)){
        season=1;
    }else if((9<=month)&&(month<=11)){
        season=2;
    }else{
        season=3;
    }
} 

// 物件売却処理
int debtprocess(void){
    int i,j;
    int count=0;
    // 資産がないとき
    if(players[turn].assets==0){
        return -1;
    }

    // 借金が資産より大きいとき,全ての物件を売却
    if(abs(players[turn].money)>=players[turn].assets){
        for(i=0;i<STATIONNUM;i++){
            // 独占解除
            if(stations[i].ismonopoly==turn+1){
                stations[i].ismonopoly=0;
            }
            for(j=0;j<stations[i].propertynum;j++){
            if(stations[i].plist[j].holder==turn+1){
                // 購入フラグ初期化
                stations[i].plist[j].holder=0;
                // 所持金を計算
                players[turn].money+=stations[i].plist[j].price;
                // 総資産を計算
                players[turn].assets-=stations[i].plist[j].price;
                // 売った物件数をカウント
                count++;
                }
            }
        }  
        return count;
    }

    // 借金が資産より小さいとき
    count +=sale(0,1);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(0,0);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(1,1);
    if(players[turn].money>=0){
        return count;
    }
    count +=sale(1,0);
    return count;
}

// カード処理
int cardprocess(int num){
    int r=1;
    int i,j,randst;
    if(num==KYUKO){ // 急行カード
        saikoro=2;
    }else if(num==TOKKYU){ // 特急カード
        saikoro=3;
    }else if(num==SINKANSEN){ // 新幹線カード
        saikoro=4;
    }else if(num==SAMMIT){ // サミットカード
        if(rand()%3!=0){
            for(i=0;i<PLAYERNUM;i++){
                players[i].x=players[turn].x;
                players[i].y=players[turn].y;
            }
        }else{
            r=0;
        }
    }else if(num==BUTTOBI){ // ぶっとびカード
        randst = rand()%STATIONNUM;
        players[turn].x = stations[randst].x*IMGSIZE;
        players[turn].y = stations[randst].y*IMGSIZE;
    }else if(num==JUOKU){ // 10億円カード
        players[turn].money+=100000;
    }else if(num==TOKUSEIREI){ // 徳政令カード
        for(i=0;i<PLAYERNUM;i++){
            if(players[i].money<0){
                players[i].money=0;
            }
        }
    }else if(num==GOUSOKKYU){ // 剛速球カード
        if(rand()%2){
        for(i=0;i<PLAYERNUM;i++){
            if(i!=turn){
                players[i].cardnum=0;
                for(j=0;j<CARDMAX;j++){
                    players[i].card[j]=0;
                }
            }
        }
        }else{
           r=0; 
        }        
    }
    dummynum=saikoro;
    return r;
}

// 変数初期化
void Initvalue(void){
    int i;
    keyboardflg=0;
    for(i=0;i<SAIKOROMAX;i++){
        dummyresult[i]=0;
    }
    direction=-1;
    selectpos=0;
}
// ゲーム開始時の処理
void startgame(void){
    if(inflg==0){
        Initvalue(); // 変数初期化
        month=3; // 4月にセット
        year=3; // 1年目にセット
        calseason(); // 季節計算
        turn=0; // プレイヤー1のターンにセット
        goalflg=0; // ゴールフラグ初期化
        inflg++;
    }else if(inflg==1){
        PutSprite(spimg[3],0,0,&spinfo[3],1);
    }else if(inflg==2){
        inflg=0;
        turnstatus=1;
    }
}
// 目的地決定処理
void desicionDist(void){
    char fname[150];
    PutSprite(spimg[2],0,0,&spinfo[2],1); // 背景表示
    if(inflg==0){
        if(goalflg==0){ // 初めて目的地をセットするとき
            // さいしょのもくてきちをきめます．
            // Eでルーレットをまわしてください．
            sprintf(fname,"saiisilonomokutekitiwokimemasumrxxxede
            llrullmsllrelttollwomawasitekudasaiimr");             
        }else if(goalflg==1){
            // つぎのもくてきちをきめます．
            // Eでルーレットをまわしてください．                
            sprintf(fname,"tuginomokutekitiwokimemasumrxxxedellru
            llmsllrelttollwomawasitekudasaiimr");                 
            }
        drawText(fname,11,225,InitWidth-22,42,0);
    }else if(inflg==1){ // 乱数生成用の設定
        dummynum=1;
        dummyresult[0]=0;
        range=STATIONNUM; // rangeを駅の数にセット
        randflg=1; // ダミータイマーロック解除
        //タイマー呼び出し
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg++;
    }else if(inflg==2){ // ダミーリザルトを表示
        drawString(stations[dummyresult[0]].name,0,InitWidth/2-80,105,1); 
        // Eでとめます．
        sprintf(fname,"xedetomemasumr");
        drawText(fname,11,225,InitWidth-22,42,0);             
    }else if(inflg==3){
        randflg=0; // タイマー停止
        randresult=rand()%range; // 結果を計算
        // 目的地の座標,名前を格納
        distination.x=stations[randresult].x;
        distination.y=stations[randresult].y;
        sprintf(distination.name,"%s",stations[randresult].name);
        inflg++;
    }else if(inflg==4){
        // 目的地を画面出力
        // もくてきちはhogeです.
        // Eをおしてください.
        sprintf(fname,"mokutekitiha%sdesumrxxxewooositekudasaiimr",
        distination.name);
        drawText(fname,11,225,InitWidth-22,42,0); 
        drawString(distination.name,0,InitWidth/2-80,105,1);  
    }else if(inflg==5){ // status更新
        inflg=0;
        if(goalflg==1){
            turnstatus=7;
        }else{
            turnstatus=2;
        }
    }
}
// ターン開始時の処理
void startTurn(void){
    int i;
    char fname[150];
    drawMap(); // マップ描画
    drawPlayer(); // プレイヤー描画
    if(inflg==0){
        saikoro=1;
        dummynum=1;
        keyboardflg=0;
        selectpos=0;
        inflg++;
    }else if(inflg==1){
        // プレイヤーカラーでダイアログ生成
        glColor3ub(playercolor[turn][0],playercolor[turn][1],
        playercolor[turn][2]);
        drawDialog(11,11,InitWidth-22,34+16);
        // hogeねんめ hugaがつ
        sprintf(fname,"%dnennmess%dgatu",year,month);
        drawString(fname,0,16,11+8,0.5);
        // 所持金表示
        drawMoney(players[turn].money,InitWidth/2,11+8+16,0,0.5);
        // hogeしゃちょう
        sprintf(fname,"%ssilatilouussssss",players[turn].name);
        drawString(fname,0,16,11+8+16,0.5);   
        // サイコロ
        // カード
        sprintf(fname,"llsaiikoroxxkallmslldoll");
        drawDialog(11,175,74,42);
        // セレクトポジション表示
        if(selectpos == 0){
            glColor3ub(255,0,0);
            drawQUAD(16,180,64,16);                 
        }else if(selectpos==1){
            glColor3ub(255,0,0);
            drawQUAD(16,196,64,16);               
        }   
        drawString(fname,0,16,180,0.5);
        // hogeしゃちょうのばんです．
        sprintf(fname,"%ssilatilouunobanndesumr",players[turn].name);
        drawText(fname,11,225,InitWidth-22,42,0);      
    }else if(inflg==2){
        if(selectpos==0){
            inflg++;
        }else{
            if(players[turn].cardnum==0){
                inflg=4;
            }else{
                selectpos=0;
                inflg=5;
            }
        }
    }else if(inflg==3){ // status更新(サイコロをふる)
        inflg=0;
        turnstatus++;
    }else if(inflg==4){ // カードがないとき
        sprintf(fname,"llkallmslldollga1maiimoaarimasennmr");
        drawText(fname,11,225,InitWidth-22,42,0);               
    }else if(inflg==5){
        glColor3ub(255,245,238);
        drawDialog(155,50,10+10*16,10+16*(players[turn].cardnum+1));
        // セレクトポジション表示
        glColor3ub(255,0,0);
        drawQUAD(160,55+selectpos*16,10*16,16);                 
        
        for(i=0;i<players[turn].cardnum;i++){
            if(players[turn].card[i]!=0){
                drawString(cardname[players[turn].card[i]-1],0,160,55+i*16,0.5);                   
            }
        }
        drawString("modoru",0,160,55+players[turn].cardnum*16,0.5);
    }else if(inflg==6){
        if(selectpos==players[turn].cardnum){ // もどるのとき
            selectpos=0;
            inflg=1;
        }else{
            rcard = cardprocess(players[turn].card[selectpos]);
            inflg++;
        }
    }else if(inflg==7){
        if(rcard==0){
            // こうげきがかわされた.
            sprintf(fname,"kouugekigakawasaretamr");
            nextflg=1;
        }else if(players[turn].card[selectpos]==KYUKO){
            // サイコロが2つになった.
            sprintf(fname,"llsaiikorollga2tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==TOKKYU){
            // サイコロが3つになった.
            sprintf(fname,"llsaiikorollga3tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==SINKANSEN){
            // サイコロが4つになった.
            sprintf(fname,"llsaiikorollga4tuninalttamr");
            nextflg=0;
        }else if(players[turn].card[selectpos]==SAMMIT){
            // ぜんしゃちょうがhogeしゃちょうのもとにあつまった.
            sprintf(fname,"zennsilatilouuga%ssilatilouunomotoniaatumalttamr",
            players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==BUTTOBI){
            // hogeしゃちょうはいったいどこへ.
            sprintf(fname,"%ssilatilouuhaiilttaiidokohe",players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==JUOKU){
            // hogeしゃちょうにプラス10億円.
            sprintf(fname,"%ssilatilouunillpurasull10oxexmr",players[turn].name);
            nextflg=1;
        }else if(players[turn].card[selectpos]==TOKUSEIREI){
            // ぜんしゃちょうのしゃっきんがちょうけしになった.
            sprintf(fname,"zennsilatilouunosilaltkinngatilouukesininalttamr");
            nextflg=1;
        }else if(players[turn].card[selectpos]==GOUSOKKYU){
            // ほかのちゃちょうのカードがなくなった.
            sprintf(fname,"hokanosilatilouunollkallmslldollganakunalttamr");
            nextflg=1;
        }
        drawText(fname,11,225,InitWidth-22,42,0);      
    }else if(inflg==8){ // 
        // 使ったカードの消去
        for(i=selectpos;i<players[turn].cardnum-1;i++){
            players[turn].card[i]=players[turn].card[i+1];
        }
        players[turn].cardnum--;
        inflg=0;
        if(nextflg==1){
            turnstatus=15; // ターン終了 
        }else{
            turnstatus++; // サイコロをふる処理
        }     
    }
}
// サイコロをふる処理
void rollDice(void){
    int i;
    char fname[150];
    drawMap();
    drawPlayer();    
    if(inflg==0){
        // ダミーサイコロを起動
        for(i=0;i<SAIKOROMAX;i++){
            dummyresult[i]=0;
        }
        range=DICEMAX;
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg=1;
    }else if(inflg==1){
        // サイコロ描画
        for(i=0;i<dummynum;i++){
            PutSprite(diceimg[dummyresult[i]], 416, 32+32*i, 
            &diceinfo[dummyresult[i]],1);
        }
        // Eでサイコロをとめます．
        sprintf(fname,"xedellsaiikorollwotomemasumr");
        drawText(fname,11,225,InitWidth-22,42,0);   
    }else if(inflg==2){
        // サイコロ結果処理
        randflg=0;
        recount=0;
        for(i=0;i<saikoro;i++){
            randresulttmp[i] = rand()%range;
            recount+=randresulttmp[i]+1;
        }
        randresult=recount;
        inflg++;
    }else if(inflg==3){
        for(i=0;i<saikoro;i++){
            PutSprite(diceimg[randresulttmp[i]], 416, 32+32*i, 
            &diceinfo[randresulttmp[i]],1);
        }       
        // Eをおしてください.
        sprintf(fname,"xewooositekudasaiimr");
        drawText(fname,11,225,InitWidth-22,42,0);
    }else if(inflg==4){
        inflg=0;
        turnstatus=5;
    }
}
// 駅移動処理
void moveMass(void){
    char fname[150];
    drawMap();
    drawPlayer();  
    // あと
    // 　　hoge
    // 　　　マス
    // もくてきち
    // huga
    sprintf(fname,"aatoxxss%dxxssssllmasullxxmokutekitixx%s",
    recount,distination.name);
    drawText(fname,340,40,125,94,0);  
    if(recount==0){ // 移動マスを消費したらstatus更新
        turnstatus=6;
    }
}
// 停車駅の判定と処理の分岐
void checkMass(void){
    int st; //止まった駅の番号を保持
    int transx,transy; // プレイヤーの座標変換用
    char fname[200];
    drawMap();
    drawPlayer();  
    if(inflg==0){
        keyboardflg=0; // キーボードロック解除
        transx = players[turn].x/IMGSIZE;
        transy = players[turn].y/IMGSIZE;
        st = getmapnum(transx,transy);
        if(st==PROPERTYMASU){ // 物件に止まったとき
            if((transx == distination.x)&&(transy == distination.y)){ // 目的地なら
                goalflg=1; // ゴールフラグをたてる
                players[turn].money+=30000; // プラス3億円
                inflg++;
            }else{ //目的地でないなら
                turnstatus=7;
            }
        }else if(st==PLUSMASU){ // プラス駅に止まったとき
            turnstatus=8;
        }else if(st==MINUSMASU){ // マイナス駅に止まったとき
            turnstatus=9;
        }else if(st==CARDMASU){ // マイナス駅に止まったとき
            turnstatus=10;
        }
    }else if(inflg==1){
        // hogeしゃちょうがhugaに1ばんのり.おめでとうございます.
        // hogeしゃちょうにプラス3億円.
        sprintf(fname,"%ssilatilouuga%sni1bannnorimroomedetouugozaiimasumr
        %ssilatilouunillpurasull3oxexmr",players[turn].name,distination.name,
        players[turn].name);
        drawText(fname,11,225,InitWidth-22,42,0);              
    }else if(inflg==2){
        inflg=0;
        turnstatus=1; // 目的地再設定
    }
}
// 物件購入処理
void purchaseProperty(void){
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        keyboardflg=0;
        selectpos=0;
        inflg++;
    }else if(inflg==1){
        drawStation(); // 物件情報描画
    }else if(inflg==2){
        inflg=0;
        turnstatus=15;
    }
}
// プラス駅の処理
void plusMass(){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        dummynum=1;
        // ダミータイマー起動
        dummyresult[0]=0;
        keyboardflg=0;
        range=plusarray[month-1][1]-plusarray[month-1][0];
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg++;            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(pluscolor[0],pluscolor[1],pluscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(plusarray[month-1][0]+dummyresult[0],
        InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);            
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = rand()%range;
        tmpmoney = plusarray[month-1][0]+randresult;
        players[turn].money+=tmpmoney;
        inflg++;
    }else if(inflg==3){
        // 所持金ダイアログ表示
        glColor3ub(pluscolor[0],pluscolor[1],pluscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(tmpmoney,InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);
        // 所持金表示
        glColor3ub(playercolor[turn][0],playercolor[turn][1],playercolor[turn][2]);
        drawDialog(11,220,InitWidth-22,42);
        drawMoney(players[turn].money,InitWidth/2,225,0,0.5);
        // しょじきん
        sprintf(fname,"silozikinn");
        drawString(fname,0,16,225,0.5);               
    }else if(inflg==4){
        inflg=0;
        turnstatus=15;
    }
}
// マイナス駅の処理
void minusMass(void){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        // ダミータイマー起動
        dummynum=1;
        dummyresult[0]=0;
        keyboardflg=0;
        range=minusarray[month-1][1]-minusarray[month-1][0];
        randflg=1;
        glutTimerFunc(RANDTIME, RandTimer, 0);
        inflg=1;            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(minuscolor[0],minuscolor[1],minuscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(-minusarray[month-1][0]-dummyresult[0],
        InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);            
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = rand()%range;
        tmpmoney = -minusarray[month-1][0]-randresult;
        players[turn].money+=tmpmoney;
        inflg++;
    }else if(inflg==3){
        // 所持金ダイアログ表示
        glColor3ub(minuscolor[0],minuscolor[1],minuscolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawMoney(tmpmoney,InitWidth/2-IMGSIZE*3,InitHeight/2-16,0,1);
        // 所持金表示
        glColor3ub(playercolor[turn][0],playercolor[turn][1],
        playercolor[turn][2]);
        drawDialog(11,220,InitWidth-22,42);
        drawMoney(players[turn].money,InitWidth/2,225,0,0.5);
        sprintf(fname,"silozikinn");
        drawString(fname,0,16,225,0.5);               
    }else if(inflg==4){
        if(players[turn].money<0){ //借金を背負ったとき
            inflg++;
        }else{ // それ以外
            inflg=0;
            turnstatus=15;
        }
    }else if(inflg==5){ // 借金返済処理
        rdebet = debtprocess(); // 売却した物件数を取得
        inflg++;
    }else if(inflg==6){
        if(rdebet==-1){
            // うれるぶっけんがありません．しゃっきんをせおってしまいました.
            sprintf(fname,"uurerubultkenngaaarimasennmrsilaltki
            nnwoseoolttesimaiimasitamr");
        }else{
            // しゃっきんをせおってしまいました.hogeけんのぶっけんをばいきゃくしました.
            sprintf(fname,"silaltkinnwoseoolttesimaiimasitamr
            %dkennnobultkennwobaiikilakusimasitamr",rdebet);
        }
        drawText(fname,11,225,InitWidth-22,42,0); 
    }else if(inflg==7){
        inflg=0;
        turnstatus=15;
    }
}
// カード駅の処理
void cardMass(void){
    char fname[150];
    drawMap();
    drawPlayer(); 
    if(inflg==0){
        if(players[turn].cardnum==CARDMAX){
            inflg=5;
        }else{
            dummynum=1;
            // ダミータイマー起動
            dummyresult[0]=0;
            keyboardflg=0;
            range=CARDNUM;
            randflg=1;
            glutTimerFunc(RANDTIME, RandTimer, 0);
            inflg=1;
        }            
    }else if(inflg==1){
        // ダミー出力
        glColor3ub(cardcolor[0],cardcolor[1],cardcolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawString(cardname[1+dummyresult[0]],0,
        InitWidth/2-IMGSIZE*4,InitHeight/2-16,1);           
    }else if(inflg==2){
        // 結果を計算
        randflg=0;
        randresult = 1 + rand()%range;
        players[turn].card[players[turn].cardnum]=randresult;
        players[turn].cardnum++;
        inflg++;
    }else if(inflg==3){
        // 入手したカードを表示
        glColor3ub(cardcolor[0],cardcolor[1],cardcolor[2]);
        drawQUAD(0,InitHeight/2-16,InitWidth,IMGSIZE);
        drawString(cardname[randresult-1],0,InitWidth/2-IMGSIZE*4,
        InitHeight/2-16,1); 
        // hogeをてにいれました.
        sprintf(fname,"%swoteniiiremasitamr",cardname[randresult-1]);
        drawText(fname,11,225,InitWidth-22,42,0);                     
    }else if(inflg==4){
        inflg=0;
        turnstatus=15;
    }else if(inflg==5){
        // これいじょうカードをもてません.
        sprintf(fname,"koreiizilouullkallmslldollwomotemasennmr");
        drawText(fname,11,225,InitWidth-22,42,0);            
    }else if(inflg==6){
        inflg=4;
    }
};
// ターン終了処理
void endTurn(void){
// ターン終了処理
    turn++;
    if(turn==3){
        month++;
    }
    // 決算月かどうか判別
    if((turn==3)&&(month==4)){
        if(year==3){
            turnstatus=17; // 最終成績
        }else{
            turn=0;
            turnstatus=16;  // 決算
        }
    }else{
        if(turn==3){ // ターン初期化
            turn=0;
        }
        if(month==MAXMONTH+1){
            month=1; // 12月まできたら1月にリセット
        }
        calseason(); // 季節再計算
        turnstatus=2; // ターンのはじめにもどる
    }
}
// 決算の処理
void processKessan(){
    int i;
    char fname[150];
    if(inflg==0){
        kessan(); // 決算処理
        // 収益を所持金に追加
        for(i=0;i<PLAYERNUM;i++){
            players[i].money+=shueki[i];
        }
        inflg++;
    }else if(inflg==1){
        // 決算のタイトル画像を表示
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[0], 0, 0, &spinfo[0],1);           
    }else if(inflg==2){
        // 背景表示
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // 決算
        drawString("keltsann",0,InitWidth/2-64,11,1);
        // しゅうえきがく
        drawString("siluuueekigaku",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
            // 名前表示
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            // 収益額表示
            drawMoney(shueki[i],InitWidth/2,75+25*i,0,0.7);
        }            
    }else if(inflg==3){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        // 背景
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // けっさん
        drawString("keltsann",0,InitWidth/2-64,11,1);
        // そうしさん
        drawString("souusisann",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
        // 名前表示
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            // 総資産表示
            drawMoney(players[i].assets+players[i].money,
            InitWidth/2,75+25*i,0,0.7);
        }
    }else if(inflg==4){
        inflg=0;
        year++; // 1年経過
        turnstatus=2;
    }
}
// ゲーム終了処理
void endgame(void){
    int i;
    char fname[150];
    if(inflg==0){
        kessan();
        for(i=0;i<PLAYERNUM;i++){
            players[i].money+=shueki[i];
        }
        inflg++;
    }else if(inflg==1){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[0], 0, 0, &spinfo[0],1);            
    }else if(inflg==2){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // さいしゅうせいせき
        drawString("saiisiluuuseiiseki",0,InitWidth/2-144,11,1);
        // しゅうえきがく
        drawString("siluuueekigaku",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
            sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            drawMoney(shueki[i],InitWidth/2,75+25*i,0,0.7);
        }            
    }else if(inflg==3){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        PutSprite(spimg[1], 0, 0, &spinfo[1],1);
        // さいしゅうせいせき
        drawString("saiisiluuuseiiseki",0,InitWidth/2-144,11,1);
        // しゅうえきがく
        drawString("souusisann",0,11,43,0.7);
        for(i=0;i<PLAYERNUM;i++){
        sprintf(fname,"%s",players[i].name);
            drawString(fname,0,11,75+25*i,0.7);
            drawMoney(players[i].assets+players[i].money,InitWidth/2,75+25*i,0,0.7);
        }
    }else if(inflg==4){
        glColor3ub(23,194,230);
        drawQUAD(0,0,InitWidth,InitHeight);
        // おつかれさまでした
        drawString("ootukaresamadesita",0,InitWidth/2-144,InitHeight/2-48,1);
        // Qでゲームをしゅうりょうします.
        drawString("xqdellgellmsllmullwosiluuurilouusimasu",
        0,InitWidth/2-120,InitHeight/2+16,0.5);          
    }
}

// ディスプレイ関数
void Display(void){
    tx = players[turn].x/IMGSIZE-CX; // 中央座標計算
    ty = players[turn].y/IMGSIZE-CY;
    glClear(GL_COLOR_BUFFER_BIT); // 描画クリア
    if(turnstatus==0){ // ゲーム初期化処理
        startgame();
    }else if(turnstatus==1){ // 目的地設定
        desicionDist();
    }else if(turnstatus==2){ // ターンのはじめ
        startTurn();
    }else if(turnstatus==3){ // 予備
        turnstatus++;
    }else if(turnstatus==4){ // サイコロをふる処理
        rollDice();
    }else if(turnstatus==5){ // マス移動
        moveMass();
    }else if(turnstatus==6){ // 条件分岐
        checkMass();
    }else if(turnstatus==7){ // 物件購入処理
        purchaseProperty();
    }else if(turnstatus==8){ // プラス駅の処理
        plusMass();
    }else if(turnstatus==9){ // マイナス駅の処理
        minusMass();
    }else if(turnstatus==10){ // カード駅の処理
        cardMass();
    }else if(turnstatus==15){ // 月別分岐
        endTurn();
    }else if(turnstatus==16){ // 決算月
        processKessan();
    }else if(turnstatus==17){ // 最終成績
        endgame();
    }
    glFlush();
}
    \end{lstlisting}


    \section{感想}
    ゲームのできについては,貧乏神を実装したかったが,満足いくものができた.しかし今回の開発は計画性に欠けていたため
    コーディングを綺麗にしきれておらず,レポートもやや力尽きているように感じている.
    開発初期は「桃鉄ぐらい簡単にできる」という意見を聞き,筆者も同じ意見であったが
    実際に開発を行ってみると難しい部分が多くあった.特に難しく時間がかかった部分は日本語の実装である.
    また,今回のコーディングでは初めてprintfの有無で実行結果が変わる事象に遭遇した.このため,授業で
    学習したgdbの理解を深める良い機会になった.
    

    \begin{thebibliography}{9}
        \bibitem{mmtt}  桃太郎電鉄,\url{https://www.konami.com/games/momotetsu/teiban/} ,閲覧日2021年1月5日
        \bibitem{springc} 伊藤 祥一,"Springs of C 楽しく身につくプログラミング",森北出版株式会社,2017
        \end{thebibliography}
\end{document}